{"pages":[{"title":"About","text":"本人擅长 Ai、Fw、Fl、Br、Ae、Pr、Id、Ps 等软件的安装与卸载，精通 CSS、JavaScript、PHP、ASP、C、C++、C#、Java、Ruby、Perl、Lisp、Python、Objective-C、ActionScript、Pascal 等单词的拼写，熟悉 Windows、Linux、OS X、Android、iOS、WP8 等系统的开关机。","link":"/about/index.html"}],"posts":[{"title":"使用GitHub搭建免费图床","text":"前言最近经过和同学的聊天中得知到了他利用Github+Hexo搭建了一个个人博客，我也试着尝试搭建了一个我自己的个人博客，为社么GitHub搭建个人博客 ？选择这个方案的原因得益于使用GitHub Page服务可以免除一些麻烦的同时得益于Git强大的版本控制，我可以随时追溯到任何一个版本：后来在实际编写和维护博客的同时我发现了一个巨大的问题：“我的那些诱人的图片该怎么办？！！！” 经过一番搜索🔍和同学推荐得知可以使用GitHub搭建免费图床！！免费！！虽然七牛云也是免费，但是需要拿出我的身份证进行实名认证!果断放弃，Google Photos也可以用作图床搭建，但在中国是无法使用的。 各方搜索我发现了一个及其实用的工具PicGo，使用他是可以非常的便捷的使用Github搭建图床 附上PicGo的链接地址 https://picgo.github.io/PicGo-Doc/ 配置Github仓库1.首先你的有一个Github账号。注册Github就不用我多言🐕 2.新建一个仓库，并且记下你取的仓库名 3.生成一个Token用于PicGo操作你的仓库 然后点击Generate new token。 把repo的勾打上即可。然后翻到页面最底部，点击Generate token的绿色按钮生成token。 注意：这个token生成后只会显示一次！你要把这个token复制一下存到其他地方以备以后要用。 配置PicGo注意：仓库名的格式是用户名/仓库，比如我创建了一个叫做hexo_pictures_source的仓库，在PicGo里我要设定的仓库名就是PureKitS/hexo_pictures_source。一般我们选择main分支即可。然后记得点击确定以生效，然后可以点击设为默认图床来确保上传的图床是GitHub。 注意：千万！千万!千万！设定仓库名选项不要有空格！！！🐕 至此配置完毕，已经可以使用了。当你上传的时候，你会发现你的仓库里也会增加新的图片了： 图片命名 以保证可以有序保存上传，对每个图片都以规定格式命名 博客文章名称-图片对应标题功能-图片序号","link":"/2021/07/11/%E4%BD%BF%E7%94%A8Github%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E5%9B%BE%E5%BA%8A/"},{"title":"Java学习:使用DOM写XML -- 绘制中国国旗的SVG文件","text":"利用 Flag.java文件绘制出一个SVG格式的中华人民共和国国旗。SVG文件参考了维基百科上的中国国旗的SVG文件 [维基百科中华人民共和国国旗](中华人民共和国国旗 - 维基百科，自由的百科全书 (wikipedia.org)) 源码已push至GitHub FlagPRC Java Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package io.pure.flagprc;import java.io.File;import java.io.FileNotFoundException;import java.io.FileOutputStream;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import javax.xml.parsers.ParserConfigurationException;import javax.xml.transform.Transformer;import javax.xml.transform.TransformerConfigurationException;import javax.xml.transform.TransformerException;import javax.xml.transform.TransformerFactory;import javax.xml.transform.TransformerFactoryConfigurationError;import javax.xml.transform.dom.DOMSource;import javax.xml.transform.stream.StreamResult;import org.w3c.dom.Document;import org.w3c.dom.Element;/** * 使用DOM绘制中国国旗的SVG文件 * @author PureK1t_SVG * @date 2020年12月11日 * @time PM17:20 * @remark * */class FlagPRC { /** * 使用DOM绘制中国国旗的SVG文件 * @param args */ public static void main(String[] args) { try { DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); factory.setNamespaceAware(true); DocumentBuilder builder = factory.newDocumentBuilder(); //生成SVG Document doc = builder.newDocument(); String namespace = &quot;http://www.w3.org/2000/svg&quot;; Element elementSvg = doc.createElementNS(namespace, &quot;svg&quot;); elementSvg.setAttribute(&quot;xmlns:xlink&quot;, &quot;http://www.w3.org/1999/xlink&quot;); elementSvg.setAttribute(&quot;width&quot;, &quot;900&quot;); elementSvg.setAttribute(&quot;height&quot;, &quot;600&quot;); elementSvg.setAttribute(&quot;viewBox&quot;, &quot;0 0 30 20&quot;); doc.appendChild(elementSvg); Element elementDef = doc.createElement(&quot;defs&quot;); elementSvg.appendChild(elementDef); Element elementPath = doc.createElement(&quot;path&quot;); elementPath.setAttribute(&quot;id&quot;, &quot;s&quot;); elementPath.setAttribute(&quot;d&quot;, &quot;M0,-1 0.587785,0.809017 -0.951057,-0.309017H0.951057L-0.587785,0.809017z&quot;); elementPath.setAttribute(&quot;fill&quot;, &quot;#ffde00&quot;); elementDef.appendChild(elementPath); Element elementRect = doc.createElement(&quot;rect&quot;); elementRect.setAttribute(&quot;width&quot;, &quot;30&quot;); elementRect.setAttribute(&quot;height&quot;, &quot;20&quot;); elementRect.setAttribute(&quot;fill&quot;, &quot;#de2910&quot;); elementSvg.appendChild(elementRect); Element elementUse1 = doc.createElement(&quot;use&quot;); elementUse1.setAttribute(&quot;xlink:href&quot;, &quot;#s&quot;); elementUse1.setAttribute(&quot;transform&quot;, &quot;translate(5,5) scale(3)&quot;); elementSvg.appendChild(elementUse1); Element elementUse2 = doc.createElement(&quot;use&quot;); elementUse2.setAttribute(&quot;xlink:href&quot;, &quot;#s&quot;); elementUse2.setAttribute(&quot;transform&quot;, &quot;translate(10,2) rotate(23.036243)&quot;); elementSvg.appendChild(elementUse2); Element elementUse3 = doc.createElement(&quot;use&quot;); elementUse3.setAttribute(&quot;xlink:href&quot;, &quot;#s&quot;); elementUse3.setAttribute(&quot;transform&quot;, &quot;translate(12,4) rotate(45.869898)&quot;); elementSvg.appendChild(elementUse3); Element elementUse4 = doc.createElement(&quot;use&quot;); elementUse4.setAttribute(&quot;xlink:href&quot;, &quot;#s&quot;); elementUse4.setAttribute(&quot;transform&quot;, &quot;translate(12,7) rotate(69.945396)&quot;); elementSvg.appendChild(elementUse4); Element elementUse5 = doc.createElement(&quot;use&quot;); elementUse5.setAttribute(&quot;xlink:href&quot;, &quot;#s&quot;); elementUse5.setAttribute(&quot;transform&quot;, &quot;translate(10,9) rotate(20.659808)&quot;); elementSvg.appendChild(elementUse5); //输出到文件 File file = new File(&quot;C:\\\\Users\\\\Purek\\\\Desktop\\\\FlagPRC.svg&quot;); Transformer t = TransformerFactory.newInstance().newTransformer(); t.transform(new DOMSource(doc), new StreamResult(new FileOutputStream(file))); } catch (ParserConfigurationException e) { // TODO Auto-generated catch block e.printStackTrace(); } catch (TransformerConfigurationException e) { // TODO Auto-generated catch block e.printStackTrace(); } catch (TransformerFactoryConfigurationError e) { // TODO Auto-generated catch block e.printStackTrace(); } catch (FileNotFoundException e) { // TODO Auto-generated catch block e.printStackTrace(); } catch (TransformerException e) { // TODO Auto-generated catch block e.printStackTrace(); } }} 运行此代码之前要修改 84 行的文件目录才可以可在桌面上生成一个 FlagPRC.svg 文件 此文件可以进行使用 如果想进一步编辑此文件 可以对此文件的XML代码进行格式化格式方法有很多 我使用的是 在线格式化工具 [菜鸟xml在线格式化](XML 在线格式化 | 菜鸟工具 (runoob.com))","link":"/2020/12/16/%E4%BD%BF%E7%94%A8DOM%E5%86%99XML%E7%BB%98%E5%88%B6%E4%B8%AD%E5%9B%BD%E5%9B%BD%E6%97%97%E7%9A%84SVG%E6%96%87%E4%BB%B6/"},{"title":"使用VPN校外连接到校园网内网","text":"暑假放假回家必定会面临一个很重要的问题：“我的校园网没有了，我怎么查分？！” 多方搜索了解到学校的服务器防火墙是山石网科在做的，根据学校的网站的教程我了解到学校在2011年给教职工开放了学校的VPN使用权我抱着试一试的心态果断冲了一把，废话不多说！！ 首先下载山石网科的的软件（PC）：点击下载 1.安装好Hillstone Secure Connect之后配置如下信息 Server：218.22.71.210(电信用户),112.31.22.130（移动联通用户) 玄学问题：如果使用的移动卡或者是移动宽带，连接成功不可用那就换成另一个服务器地址 Port：4433 Username：校园统一账户（学号） Password：校园统一账户的密码 2.配置好如下图 3.移动端客户端 iOS客户端：App Store中为Hillstone Access Client Android客户端：直接在应用商店搜索Hillstone secure Connect扫描下方二维码也可下载","link":"/2021/07/12/%E4%BD%BF%E7%94%A8VPN%E6%A0%A1%E5%A4%96%E8%BF%9E%E6%8E%A5%E5%88%B0%E6%A0%A1%E5%9B%AD%E7%BD%91%E5%86%85%E7%BD%91/"},{"title":"Android视图绑定ViewBinding的使用","text":"概述 在我们的开发过程中需要获取XML布局文件中的ViewId以便其赋值显示，所以我们习惯了使用findViewById进行操作 从Android Studio 3.6 开始，视图绑定能够通过生成绑定对象来替代 findViewById，从而可以帮您简化代码、移除 bug，并且从findViewById 的模版代码中解脱出来。 在build.gradle中开启视图绑定 开启视图绑定无需引入任何额外依赖，从Android Studio 3.6开始，视图绑定将会内建于Anroid Gradle插件中。需要打开视图绑定的话只需要在build.gradle文件中配置viewBinding选项 123456// 需要 Android Gradle Plugin 3.6.0android { viewBinding { enabled = true }} 在Android Studio 4.0中，viewBinding变成属性被整合到了buildFeatures选项中所以配置要改正； 123456// Android Studio 4.0android { buildFeatures { viewBinding = true }} 配置完成后，视图绑定就会为所有布局文件自动生成对应的绑定类。无需修改原有的XML布局文件，视图绑定将根据你现有的布局自动完成所有工作。 视图绑定将会根据现有的XML布局文件，为Module内所有的布局文件生成绑定对象。 在Activity中使用视图绑定 假设你有一个布局文件叫做activity_main.xml,开启视图绑定后就会自动生成相应的ActivityMainBinding绑定类 1234567891011121314151617181920package io.pure.myapplication;import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;import io.pure.myapplication.databinding.ActivityMainBinding;public class MainActivity extends AppCompatActivity { private ActivityMainBinding binding; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); //通过调用生成的绑定类中包含的静态 inflate() 方法，创建该绑定类的实例以供 Activity使用 binding = ActivityMainBinding.inflate(getLayoutInflater()); //调用 getRoot() 方法获取对根视图的引用 将根视图传递到 setContentView() 使其成为屏幕上的活动视图 setContentView(binding.getRoot()); //获取控件ID并执行操作 binding.textView01.setText(&quot;Hello World&quot;); }}","link":"/2021/02/25/%E4%BD%BF%E7%94%A8%E8%A7%86%E5%9B%BE%E7%BB%91%E5%AE%9AViewBinding/"},{"title":"使用批处理程序让电脑连接学校WiFi","text":"桌面创建txt文本文件，修改后缀名为bat 友情提示：只适用于本校_安徽机电 1234567891011121314151617181920212223242526272829303132333435363738394041@echo offnetsh wlan delete profile Ahcme-edu( echo ^&lt;?xml version=&quot;1.0&quot;?^&gt; echo ^&lt;WLANProfile xmlns=&quot;http://www.microsoft.com/networking/WLAN/profile/v1&quot;^&gt; echo ^&lt;name^&gt;Ahcme-edu^&lt;/name^&gt; echo ^&lt;SSIDConfig^&gt; echo ^&lt;SSID^&gt; echo ^&lt;name^&gt;Ahcme-edu^&lt;/name^&gt; echo ^&lt;/SSID^&gt; echo ^&lt;nonBroadcast^&gt;false^&lt;/nonBroadcast^&gt; echo ^&lt;/SSIDConfig^&gt; echo ^&lt;connectionType^&gt;ESS^&lt;/connectionType^&gt; echo ^&lt;connectionMode^&gt;auto^&lt;/connectionMode^&gt; echo ^&lt;autoSwitch^&gt;false^&lt;/autoSwitch^&gt; echo ^&lt;MSM^&gt; echo ^&lt;security^&gt; echo ^&lt;authEncryption^&gt; echo ^&lt;authentication^&gt;WPA2^&lt;/authentication^&gt; echo ^&lt;encryption^&gt;AES^&lt;/encryption^&gt; echo ^&lt;useOneX^&gt;true^&lt;/useOneX^&gt; echo ^&lt;FIPSMode xmlns=&quot;http://www.microsoft.com/networking/WLAN/profile/v2&quot;^&gt;false^&lt;/FIPSMode^&gt; echo ^&lt;/authEncryption^&gt; echo ^&lt;PMKCacheMode^&gt;enabled^&lt;/PMKCacheMode^&gt; echo ^&lt;PMKCacheTTL^&gt;720^&lt;/PMKCacheTTL^&gt; echo ^&lt;PMKCacheSize^&gt;128^&lt;/PMKCacheSize^&gt; echo ^&lt;preAuthMode^&gt;disabled^&lt;/preAuthMode^&gt; echo ^&lt;OneX xmlns=&quot;http://www.microsoft.com/networking/OneX/v1&quot;^&gt; echo ^&lt;cacheUserData^&gt;true^&lt;/cacheUserData^&gt; echo ^&lt;authMode^&gt;user^&lt;/authMode^&gt; echo ^&lt;EAPConfig^&gt;^&lt;EapHostConfig xmlns=&quot;http://www.microsoft.com/provisioning/EapHostConfig&quot;^&gt;^&lt;EapMethod^&gt;^&lt;Type xmlns=&quot;http://www.microsoft.com/provisioning/EapCommon&quot;^&gt;25^&lt;/Type^&gt;^&lt;VendorId xmlns=&quot;http://www.microsoft.com/provisioning/EapCommon&quot;^&gt;0^&lt;/VendorId^&gt;^&lt;VendorType xmlns=&quot;http://www.microsoft.com/provisioning/EapCommon&quot;^&gt;0^&lt;/VendorType^&gt;^&lt;AuthorId xmlns=&quot;http://www.microsoft.com/provisioning/EapCommon&quot;^&gt;0^&lt;/AuthorId^&gt;^&lt;/EapMethod^&gt;^&lt;Config xmlns=&quot;http://www.microsoft.com/provisioning/EapHostConfig&quot;^&gt;^&lt;Eap xmlns=&quot;http://www.microsoft.com/provisioning/BaseEapConnectionPropertiesV1&quot;^&gt;^&lt;Type^&gt;25^&lt;/Type^&gt;^&lt;EapType xmlns=&quot;http://www.microsoft.com/provisioning/MsPeapConnectionPropertiesV1&quot;^&gt;^&lt;ServerValidation^&gt;^&lt;DisableUserPromptForServerValidation^&gt;false^&lt;/DisableUserPromptForServerValidation^&gt;^&lt;ServerNames^&gt;^&lt;/ServerNames^&gt;^&lt;/ServerValidation^&gt;^&lt;FastReconnect^&gt;true^&lt;/FastReconnect^&gt;^&lt;InnerEapOptional^&gt;false^&lt;/InnerEapOptional^&gt;^&lt;Eap xmlns=&quot;http://www.microsoft.com/provisioning/BaseEapConnectionPropertiesV1&quot;^&gt;^&lt;Type^&gt;26^&lt;/Type^&gt;^&lt;EapType xmlns=&quot;http://www.microsoft.com/provisioning/MsChapV2ConnectionPropertiesV1&quot;^&gt;^&lt;UseWinLogonCredentials^&gt;false^&lt;/UseWinLogonCredentials^&gt;^&lt;/EapType^&gt;^&lt;/Eap^&gt;^&lt;EnableQuarantineChecks^&gt;false^&lt;/EnableQuarantineChecks^&gt;^&lt;RequireCryptoBinding^&gt;false^&lt;/RequireCryptoBinding^&gt;^&lt;PeapExtensions^&gt;^&lt;PerformServerValidation xmlns=&quot;http://www.microsoft.com/provisioning/MsPeapConnectionPropertiesV2&quot;^&gt;false^&lt;/PerformServerValidation^&gt;^&lt;AcceptServerName xmlns=&quot;http://www.microsoft.com/provisioning/MsPeapConnectionPropertiesV2&quot;^&gt;false^&lt;/AcceptServerName^&gt;^&lt;PeapExtensionsV2 xmlns=&quot;http://www.microsoft.com/provisioning/MsPeapConnectionPropertiesV2&quot;^&gt;^&lt;AllowPromptingWhenServerCANotFound xmlns=&quot;http://www.microsoft.com/provisioning/MsPeapConnectionPropertiesV3&quot;^&gt;true^&lt;/AllowPromptingWhenServerCANotFound^&gt;^&lt;/PeapExtensionsV2^&gt;^&lt;/PeapExtensions^&gt;^&lt;/EapType^&gt;^&lt;/Eap^&gt;^&lt;/Config^&gt;^&lt;/EapHostConfig^&gt;^&lt;/EAPConfig^&gt; echo ^&lt;/OneX^&gt; echo ^&lt;/security^&gt; echo ^&lt;/MSM^&gt; echo ^&lt;/WLANProfile^&gt;) &gt;wl.xmlnetsh wlan add profile filename = &quot;wl.xml&quot;del wl.xml","link":"/2021/07/11/%E4%BD%BF%E7%94%A8%E6%89%B9%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E8%BF%9E%E6%8E%A5%E5%AD%A6%E6%A0%A1%E7%9A%84WiFi/"},{"title":"开始学习Laravel","text":"前言 Laravel是 Taylor Otwell 开发的一款基于 PHP 语言的 Web 开源框架，旨在实现的Web软件的MVC架构。让你可以通过简单、优雅的表达式语法开发出很棒的Web应用，Laravel同时拥有更富有表现力的语法、高质量的文档、丰富的扩展包，可以让你从杂乱的代码中解脱出来。 安装安装composer Laravel 使用 Composer 来管理项目依赖。因此，在使用 Laravel 之前，请确保您的机器上已经安装了 Composer。 通过composer全局安装laravel1composer global require laravel/installer 使用laravel new blog（you project name) Laravel 使用 Composer 来管理项目依赖。因此，在使用 Laravel 之前，请确保您的机器上已经安装了 Composer。 1laravel new blog(you project name) 使用PHP内置服务器提供服务 如果你在本地安装了 PHP，并且你想使用 PHP 内置的服务器来为你的应用程序提供服务，则可以使用 Artisan 命令 serve。该命令会在 http://localhost:8000 上启动开发服务器： 1php artisan serve 配置数据库修改数据库的连接配置文件 数据库的连接配置文件位于 config/database.php，和很多其他 Laravel 配置一样，你可以为数据库配置多个「连接」，然后决定将哪个「连接」作为默认连接。 1234567891011121314/*|--------------------------------------------------------------------------| Default Database Connection Name|--------------------------------------------------------------------------|| Here you may specify which of the database connections below you wish| to use as your default connection for all database work. Of course| you may use many connections at once using the Database library.|*/'default' =&gt; env('DB_CONNECTION', 'mysql'), 修改 .env文件内的变量 当然，默认数据库连接、数据库名称以及数据库用户名和密码等敏感信息都保存到 .env 文件中了，然后通过 env 辅助函数读取： 123456DB_CONNECTION=mysql //laravel默认使用mysqlDB_HOST=127.0.0.1DB_PORT=3306DB_DATABASE=laravel_demo //数据库DB_USERNAME=root //mysql用户名DB_PASSWORD=rootme //mysql密码 运行命令迁移数据库 修改好.env配置文件的变量,需要在MySQL中创建一个laravel_demo的数据库,然后运行数据库迁移命令行执行数据库迁移 1php artisan migrate 快速入门安装基本入门套件Laravel Breeze Laravel Breeze 是一个最小化的 Laravel 认证功能完整实现扩展包，包含了登录、注册、密码重置、邮箱验证和密码确认等功能。Laravel Breeze 的视图层通过 Blade 模板 + Tailwind CSS 实现。Breeze 为构建一个全新的 Laravel 应用提供了一个良好的起点。 首先需要创建一个新的laravel应用,并且配置好数据库,然后运行数据库迁移; 123456laravel new blogcd blog配置数据库配置文件，运行命令行进行迁移php artisan migrate 创建好新的laravel应用后，你可以通过Composer来安装Laravel breeze： 1composer require laravel/breeze --dev 安装好 Laravel Breeze 扩展包后，可以运行 breeze:install Artisan 命令，这个命令会发布认证视图、路由和控制器等资源到项目目录，这样一来，你可以可以完全接管这些认证代码的功能实现和自定义了。此外，还需要编译前端资源让 JavaScript 和 CSS 代码生效： 123php artisan breeze:install //发布认证视图、路由和控制器等资源到项目目录；npm install &amp;&amp; npm run dev //编译前端资源让JavaScript 和 css 代码生效 接下来，你就可以在浏览器中访问 /login 和 /register URL 了，所有的 Breeze 路由都定义在 routes/auth.php 文件中。 laravel路由入门 对任何一个 Web 应用框架而言，通过 HTTP 协议处理用户请求并返回响应都是核心必备功能，也就是说，对于我们学习和使用一个 Web 框架，第一件要做的事情就是定义应用路由，否则，将无法与终端用户进行交互。而我们的 Laravel 从入门到精通系列教程之旅也将从路由开始，在这篇真正意义上的开篇教程中，我们将学习如何定义路由，然后将其指向要执行的代码，并处理各种路由;需求。 路由入门 在创建的laravel应用中，定义路由有两个入口，一个是routes/web.php,用于处理终端用户通Web浏览器直接访问的请求，另一个是routes/api.php,用于处理其他接入方的API请求； 定义路由最简单的方式就是在routes/web.php中定义一个路径以及一个映射到该路径的闭包函数： 1234//routes/web.phpRoute::get('/', function(){ return 'Hello, World!';}); 运行php artisan serve访问应用首页时，就可以看到页面显示Hello，World！这一行字符串。 这就是一个简单的laravel路由定义，但是涵盖了一个Web框架的基本功能：处理请求，返回响应； 使用match和any实现相应多个或所有HTTP请求的路由； 1234567Route::match(['post', 'get'], 'match', function(){ echo 'match';});Route::any('any', function(){ echo 'any';}); 控制器Controller控制器的基本构造 命名空间 引入命名空间 类名 继承基类 使用命令在应用的app/Http/Controllers目录下创建一个UserController控制器 12//使用命令创建 名为 UserController的控制器php artisan make:controller UserController 使用路由调用控制器方法 1234567891011121314151617181920212223//Route::请求方法（'请求的url地址'，[控制器::class, '引用的控制器方法']);//在 UserController 控制器中编写 Test 类&lt;?phpnamespace App\\Http\\Controllers;use Illuminate\\Http\\Request;class UserController extends Controller{ public function Test(){ return phpinfo(); }}//路由引用控制器内的方法//Route::请求方法（'请求的url地址'，[控制器::class, '引用的控制器方法']);//调用控制器方法 UserControllerRoute::get('Controller', [UserController::class, 'Test']); 视图，数据库操作简单的数据库操作 在应用中新建的UserController控制器中编写insert类 12345678public function insert(){ return DB::table(&quot;users&quot;) -&gt;insert([ 'name' =&gt; 'haohongxin', 'email' =&gt; 'purekit.ahcme@outlook.com', 'password' =&gt; 'hhxrootme' ]);} 编写路由调用insert类 1234//调用insert方法 crudRoute::get('insert', [UserController::class, 'insert']); 在应用中新建的UserController控制器中编写增删改查 功能类 12345678910111213141516171819202122232425262728293031323334353637class UserController extends Controller{ //添加数据 public function insert(){ return DB::table(&quot;users&quot;) -&gt;insert([ 'name' =&gt; '郝宏鑫 ', 'email' =&gt; 'purekit.ahcme@gmail.com', 'password' =&gt; 'hhxrootme' ]); } //修改数据 public function update(){ return DB::table(&quot;users&quot;) -&gt;where('id', '1') -&gt;update(['name' =&gt; 'purekits']); } //查询数据 public function select(){ $customer = DB::table('customer') -&gt;get(); dd($customer); } //删除数据 public function delete(){ return DB::table('users') -&gt;where('id','2') -&gt;delete(); }} 在web.php路由表中引用控制器的功能类 123456789101112131415//创建路由组 整理 增删改查Route::prefix('db')-&gt;group(function(){ //添加数据 Route::get('insert', [UserController::class, 'insert']); //修改数据 Route::get('update', [UserController::class, &quot;update&quot;]); //查询数据 Route::get('select', [UserController::class, 'select']); //删除数据 Route::get('delete', [UserController::class, 'delete']);});","link":"/2021/07/11/%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0Laravel/"},{"title":"浅谈高数和编程","text":"浅谈高数和编程高数以及其他数学来讲对于变成尤其是应用层编程，都是属于一个充分非必要的条件。 大部分编程来讲，对于高数的要求能力不高，我们知道程序是由数据结构和算法组成的但是如果不是算法工程师不是研究性的编程、机器学习、人工智能领域以及大数据分析。基本的数学知识就能满足编程尤其是应用层的编程基本很少用到算法和高数的知识，很多时候你要的东西已经被封装好。 大一就要结束了记得刚开始接触高数的时候，确实觉得力不从心，不知道改怎么学能够将公式运用自如，渐渐的发现，其实那些公式并不是死记硬背才行只要充分理解了各个知识点，遇到题目可以分析出自己的解题思路就能吧题目解出来，所以学习高等数学记忆的负担轻了，还记得当时学习微积分的时候怎么也学不好。看过就忘（学英语也是），不过还好学的还可以，其实我觉得高等数学的学习木的并不是为了所谓的不挂科，因此我们的学习不能停留在接触答案作为目标。我们必须知道解题过程的每一步的依据。最初我们要把定理的内容记住，至少能够做的下来题目，然而我试着认真的推导定理，尽管过程并不轻松但是我却认为非常值得，因为只有通过字的探索的知识才是掌握的最好。","link":"/2020/08/02/%E6%B5%85%E8%B0%88%E9%AB%98%E6%95%B0%E5%92%8C%E7%BC%96%E7%A8%8B/"},{"title":"Android Studio &amp;&amp; Android 开发笔记","text":"一名沙雕大学生的Android学习笔记 第一章: 活动Activity 活动 Acitivity 是最吸引用户的地方，它是一种可以包含用户界面的组件，主要用于和用户交互 创建活动布局 勾选Generate Layout File表示会自动为此 活动 创建一个对应的布局文件， 勾选Launcher Acitivity表示会自动为此活动设置为当前项目的主要活动 活动的基本用法创建和加载布局 创建布局文件时选择了LinearLayout作为根元素，因此布局文件中已经有一个LinearLayout元素了，现在我们对这个布局稍做编辑，添加一个按钮： 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;Button android:id=&quot;@+id/button_1&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Button 1&quot;/&gt;&lt;/LinearLayout&gt; android:id：是给当前元素定义一个唯一标识符，@+id/id_name用于在XML中定义一个id ， @id则是需要在XML中引用一个id. android:layout_width：指定了当前元素的宽度，这里使用了match_parent表示让当前元素和父元素一样宽此时父元素则是整个布局页面. android:layout_height：指定了当前元素的高度，这里使用了wrap_content表示当前元素的高度只要刚好包含里面的内容就行. android:text：指定了元素的中显示的文字内容. 在AndroidManifest文件中注册 活动注册声明要放在&lt;application&gt;标签内，通过&lt;activity&gt;标签来对活动进行注册的 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;io.pure.firsttestacitivity&quot;&gt; &lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:roundIcon=&quot;@mipmap/ic_launcher_round&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/Theme.FirstTestAcitivity&quot;&gt; &lt;activity android:name=&quot;.FirstAcitivity&quot; android:label=&quot;This is FirstAcitivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot;&gt; &lt;/action&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; &lt;activity&gt;标签中我们使用android:name来指定具体注册那一个活动，由于最外层的的&lt;manifest&gt;标签中已经通过package属性指定了程序的包名是io.pure.firsttestacitivity因此注册活动时就可以省略前一部分，直接使用.FirstActivity. &lt;intent-filter&gt;标签里添加&lt;android:name=&quot;android.intent.action.MAIN&quot;/&gt; &amp;&amp; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;用来声明程序主活动. 在活动中使用Toast Toast是Android系统提供的一种非常好的提醒方式，在程序中可以使用它将一些短小的信息通知给用户，这些信息会在一段时间后自动消失，并且不会占用任何屏幕空间 123456789101112131415@Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.first_test_layout); Button button1 = (Button) findViewById(R.id.button_1); // 调用setOnClickListener() 方法为 button1 注册监听器 button1.setOnClickListener(new View.OnClickListener(){ @Override public void onClick(View v) { Toast.makeText(FirstAcitivity.this, &quot;You clicked Button 1&quot;, Toast.LENGTH_SHORT).show(); } }); } 通过静态方法makeText()创建出一个Toast对象，然后调用show()将Toast显示出来，makeText()方法需要传入3个参数， 第一个参数是Context也就是Toast要求的上下文，第二个参数是Toast显示的文本内容：文本内容太也可以用通过app/src/res/values/string.xml文件内定义，使用getResouces().getString(R.string.value)获取到，第三个参数是Toast显示的时长，有两个内置常量可以选择Toast.LENGTH_SHORT&gt;默认显示2秒 &amp;&amp; Toast.LENGTH_LONG&gt;默认显示3.5秒. 在活动中使用Menu 首先在 res目录下面创建一个menu文件夹，接着在此文件夹下再新建一个名叫main菜单文件，右击menu &gt; New &gt; Menu resouces fil &gt; main.xml. 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:id=&quot;@+id/add_item&quot; android:title=&quot;Add&quot;/&gt; &lt;item android:id=&quot;@+id/remove_item&quot; android:title=&quot;Remove&quot;/&gt;&lt;/menu&gt; 这里我们创建了两个菜单项，其中&lt;item&gt;标签就是用来创建具体某一个菜单项，然后通过android:id给这个&lt;item&gt;指定一个唯一的标识符，通过android:title给&lt;item&gt;指定一个名称. 接着我们重新回到FirstAcitivity中来重写onCreateOptionsMenu()方法，重写方法可以使用Ctrl + O快捷键 123456 //重写 onCreateOptionsMenu() 方法用于调用菜单资源文件 显示菜单@Override public boolean onCreateOptionsMenu(Menu menu) { getMenuInflater().inflate(R.menu.main, menu); return true; } 通过getMenuInflater()方法能够得到MenuInflater对象，再调用它的Inflater()方法就可以给当前活动创建才当了，Inflater()方法接收两个参数，第一个参数用于指定我们通过那一个资源文件来创建菜单，这里传入R.menu.main，第二个参数用于指定我们的菜单项将添加到哪一个Menu对象当中，这里直接使用onCreateOptionsMenu()方法传入的menu参数，然后给这个方法返回true, true用来表示允许创建的菜单显示出来，如果返回了false,创建的菜单将无法显示. 定义显示菜单响应事件， 在``FirstActivity中重写onOptionsItemSelected()`方法： 1234567891011121314 //重写 onOptionsItemSelected() 方法定义菜单响应事件@Override public boolean onOptionsItemSelected(@NonNull MenuItem item) { switch (item.getItemId()) { case R.id.add_item: Toast.makeText(this, &quot;You clicked Add&quot;, Toast.LENGTH_SHORT).show(); break; case R.id.remove_item: Toast.makeText(this, &quot;You clicked Remove&quot;, Toast.LENGTH_LONG).show(); break; default: } return true; } 在 onOptionsItemSelected()方法中，通过调用item.getItemId()来判断我们点击的是哪一个菜单项，然后给每个菜单项加入子的逻辑处理，这里我们弹出一个刚学的的Toast. 销毁一个活动 通过点击Back键销毁当前活动，不过如果你不想通过按键的方式，而是希望使用代码的方式来销毁活动，Acitivity类提供了一个finish()方法，在活动中调用此方法就可以销毁活动. 1234567button1.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { finish(); } }); 再次运行程序，这是点击一下按钮， 当前活动就被成功销毁了，效果同按下Back键. 使用Intent在活动之间穿梭使用显式Intent 创建活动，右击app &gt; New &gt; Acitivity &gt; Empty Acitivity我们为此活动命名SecondAcitivity并且勾选Generate Layout File为此活动添加布局文件，但不要勾选Launcher Acitivity. 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.SecondActivity&quot;&gt; &lt;Button android:id=&quot;@+id/button_2&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Button 2&quot;/&gt;&lt;/LinearLayout&gt; 为生成的activity_second.xml布局文件替换成以上代码，同时还手动定义了一个按钮按钮显示为Button 2, 查看AndroidManifest.xml文件中是否注册SecondAcitivity活动，如果Android Studio没有自动完成，我们手动添加&lt;activity&gt;标签写入&lt;android:name /&gt;属性. 由于SecondAcitivity不是主活动，因此不需要配置&lt;intent-filter&gt;标签。 Intent是Android程序中各组件之间进行交互的一种重要方式，它不仅可以指明当前组件想要执行的动作，还可以在不同组件之间传递数据，Intent一般可被用于启动活动、启动服务以及发送广播等场景. Intent大致可以分为两种：显式Intent和隐式Intent，现在学习显式Intent如何使用. Intent有多个构造函数的重载，其中一个是Intent(Context packageContext, Class&lt;?&gt;cls)这个构造函数接收两个参数，其中第一个参数是Context要求提供一个启动活动的上下文，第二个参数Class则是指定想要启动的目标活动，通过这个构造函数就可以构建出Intent的“意图”， Acitivity类中提供了一个startAcitivity()方法用于启动活动，它接收一个Intent参数，这里我们将构建好的Intent传入startAcitivity()方法就可以启动目标活动了. 12345678//为 button1 注册监听器 button1.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent intent = new Intent(FirstAcitivity.this, SecondActivity.class); startActivity(intent); } }); 使用隐式Intent 相比于显式Intent，隐式Intent含蓄了许多，他不明确指出我们想要启动哪一个活动，而是制定了一系列更为抽象的action &amp;&amp; category等信息然后交由系统去分析这个Intent并帮我们找出合适的活动去启动， 合适的活动：简单来说就是可以响应我们这个隐式Intent的活动，那么目前我们的SecondAcitivity可以响应什么养的隐式Intent呢？ 通过在&lt;activity&gt; &gt; &lt;intent-filter&gt;标签内配置的内容，可以指定当前活动能够相应的action &amp;&amp; categroy打开AndroidManifest.xml添加如下代码： 1234567&lt;activity android:name=&quot;.SecondActivity&quot; android:label=&quot;This is SecondAcitvity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;io.pure.firsttestacitivity.ACTION_START&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 在&lt;action&gt;标签中我们指明了当前活动可以响应io.pure.firsttestactivity.ACTION_START这个action，而&lt;category&gt;标签中包含了一些附加信息，更加精确的指明了当前的活动能够响应的Intent中还可能带有的category，只有&lt;action&gt; &amp;&amp; &lt;category&gt;中的内容同时能够匹配上Intent中指定的action &amp;&amp; &lt;category&gt;时，这个活动才能响应Intent，修改FirstTestActivity中的按钮点击事件： 12345678//为 button1 注册监听器 button1.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent intent = new Intent(&quot;io.pure.firsttestacitivity.ACTION_START&quot;); startActivity(intent); } }); 可以看到，我们使用了Intent的另一个构造函数，直接而将action的字符串传了进去，可以看见现在Android Studio中的Intent参数提示为action,表明我们想要启动能够响应io.pure.firsttestacitivity.ACTION_START这个action活动，前面说了需要&lt;action&gt; &amp;&amp; &lt;category&gt;同时匹配才可以响应，为什么这里没有看见指定category，这是因为我们在AndroidManifest.xml中&lt;category&gt;标签中的android.intent.category.DEFAULT是一种默认的category在调用startActivity()方法时会自动将这个category添加到Intent中. 现在重新运行程序发现你使用隐式Intent已经成功了，在&lt;action&gt; &amp;&amp; &lt;category&gt;中的内容已经生效了. 每个Intent中只能指定一个action但却能指定多个category这里我们指定了一个自定义的category值为io.pure.fifsttestacitivity.MY_CATEGORY，重新运行程序你会发现，程序崩溃了！Android Studio 中使用Alt + 6 打开logcat查看错误日志， 12342020-12-27 20:08:52.801 25783-25783/io.pure.firsttestacitivity E/AndroidRuntime: FATAL EXCEPTION: main Process: io.pure.firsttestacitivity, PID: 25783 android.content.ActivityNotFoundException: No Activity found to handle Intent { act=io.pure.firsttestacitivity.ACTION_START cat=[io.pure.firsttestactivity.MY_CATEGORY] } 错误信息提醒我们没有发现处理意图的活动即是没有任何一个活动可以响应我们的Intent，这是因为我们刚刚在Intent中新增了一个category, 而AndroidManifest.xml &gt; SecondActivity &gt; &lt;intent-filter&gt;标签中并没有声明可以响应这个category 所以就出现了没有任何活动可以响应该Intent的情况， 12345678&lt;activity android:name=&quot;.SecondActivity&quot; android:label=&quot;This is SecondAcitvity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;io.pure.firsttestacitivity.ACTION_START&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt; &lt;category android:name=&quot;io.pure.firsttestactivity.MY_CATEGORY&quot;/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 我们向&lt;intent-filter&gt;中在添加一个category的声明，要保留默认声明哦！ 更多隐式Intent的用法 使用隐式Intent我们不仅可以启动自己程序内的活动，还可以启动其他程序的活动，这使多个应用程序之间的功能共享成为了可能，比如说你的程序中要站是一个网页这是你没必要自己去实现一个浏览器，而是只需要调用系统的浏览器来打开这个网页就行了，修改FirstTestAcitivity中的按钮点击事件代码如下： 12345678button1.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent intent = new Intent(Intent.ACTION_VIEW); intent.setData(Uri.parse(&quot;https://baidu.com&quot;)); startActivity(intent); } }); 首先指定了Intent的action是Intent.ACTION_VIEW，这是一个Android系统内置的动作，其常量值为android.intent.action.VIEW，然后通过Url.parse()这个方法将一个网址字符串解析成一个Uri对象，再调用setData()方法将这个Uri对象传递进去， 重新运行程序， 点击按钮就会可以看见打开了系统浏览器，方法其实并不复杂，他接收一个Uri对象，主要用于指定当前Intent正在操作的数据，而这些数据同城都是以字符串的形式传入到Uri.parse()方法中解析产生的. 于此对应我们还可以在&lt;intent-filter&gt;中在配置一个&lt;data&gt;标签，用于更精确的指定当前活动能够响应什么类型的数据，&lt;data&gt;标签中主要可以配置一下内容： android:scheme &gt; 用于指定数据的协议部分，如上面的http部分. android:host &gt; 用于指定数据的主机名部分，如上面的baidu.com部分. android:port &gt; 用于指定数据的端口部分，一般紧随在主机名之后. android:path &gt; 用于指定主机名和端口之后的部分，如一段网址跟在域名之后的内容地址. android:mimeType &gt; 用于指定可以处理的数据类型，允许使用通配符的方式进行指定. 只有&lt;data&gt;标签中指定的内容和Intent中携带的Data完全一致时，当前活动才能够响应该Intent，不过一般的&lt;data&gt;标签中都不会指定太多内容，如上面例子中 其实只需要指定android:scheme=&quot;http&quot;就可以响应所有的http协议的Intent了. 除了指定http协议外，我们还可以指定很多其他协议，比如geo &amp;&amp; tel等，下面的代码展示了如何在我们的程序中调用系统拨号界面. 12345678button1.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent intent = new Intent(Intent.ACTION_DIAL); intent.setData(Uri.parse(&quot;tel:5556&quot;)); startActivity(intent); } }); 向下一个活动传递数据 Intent中提供了一系列putExtra()方法的重载，可以把我们想要的传递的数据暂存在Intent中，启动了另一个活动后，只需要把这些数据再从Intent中去取出就可以. 123456789button1.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { String data = &quot;HelloWorld!&quot;; Intent intent = new Intent(FirstAcitivity.this, SecondActivity.class); intent.putExtra(&quot;extra_data&quot;, data); startActivity(intent); } }); 这里还是使用显示Intent的方式启动SecondAcitivity，并通过putExtra()方法传递了一个字符串，putExtra()方法这里接收了两个参数，第一个参数是key，第二个是value，然后我们在SecondAcitivity中将传递的数据取出并打印出来： 123456789@Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_second); Intent intent = getIntent(); String data = intent.getStringExtra(&quot;extra_data&quot;); Log.d(&quot;SecondAcitivity&quot;, data); } 首先可以通过getIntent()方法获取到用于启动SecondAcitivity的Intent然后调用getStringExtra()方法传入对应的key就可以得到相应的数据了，这里由于我们传递的是字符串所以使用的getStringExtra()方法来获取传递的数据，如果传递的整形数据则使用getIntExtra()方法，如果传递的是布尔类型数据，则使用getBooleanExtra()方法，以此类推. 重新运行程序，打开logcat选择到Debug可以看见我们从FirstAcitivity中传递过来并打印的数据. 返回数据给上一个活动 返回上一个活动只需要按一下Back键就可以，并没有一个用于启动活动Intent来传递数据，通过查阅文档你会发现，Acitivity中还有一个startAcitivityForResult()方法也适用于启动活动的但这个方法期望在活动销毁的时候能够返回一个结果给上一个活动， startAcitivityForResult()方法接收两个参数，第一个参数还是Intent，第二个参数是请求码requestCode，用于在之后回调中判断数据的来源，修改FirstAcitivity中按钮的点击事件： 12345678button1.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { String data = &quot;HelloWorld!&quot;; Intent intent = new Intent(FirstAcitivity.this, SecondActivity.class); startActivityForResult(intent, 1); } }); 这里我们使用了startAcitivityForResult()方法启动SecondAcitivity请求码只要是一个唯一值就可以了，这里传入了1，接下来我们在SecondAcitivity中给按钮注册事件： 12345678910btn2 = (Button) findViewById(R.id.button_2); btn2.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent intent = new Intent(); intent.putExtra(&quot;data_return&quot;, &quot;HelloWorld!&quot;); setResult(RESULT_OK, intent); finish(); } }); 可以看见我们还是构建了一个Intent不过这个Intent仅仅是用于传递数据而已，他并没有指定意图，然后调用了setResult()方法用于向上一个活动返回数据的，setResult()方法接收两个参数，第一个参数用于向上一个活动返回处理结果，一般只使用RESULT_OK &amp;&amp; RESULT_CANCELED这两个值，第二个参数则是把带有数据的Intent传递回去，然后调用了finish()方法来销毁当前的活动 由于我们使用startAcitivityForResult()方法来启动SecondAcitivity，在SecondAcitivity被销毁之后会回调上一个活动的onAcitivityResult()方法因此我们需要在FirstAcitivity中重写这个方法来获取返回的数据， 12345678910111213@SuppressLint(&quot;MissingSuperCall&quot;) @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { switch (requestCode){ case 1: if (resultCode == RESULT_OK){ String returnedData = data.getStringExtra(&quot;data_return&quot;); Log.d(&quot;FirstAcitivity&quot;, returnedData); } break; default: } } onAcitivityResult()带有三个参数，第一个参数是requestCode，第二个参数是resultCode，即是我们在启动活动传入的请求码，第二个参数即是我们在返回数据时传入的处理结果，第三个参数是data即是携带返回数据的Intent由于在一个活动中有可能调用startAcitivityForResult()方法来启动很多不同的活动每一个活动返回的数据都会回调到onAcitivityResult()方法中因此我们首先要做的就是通过检查requestCode来判断数据来源，确定数据是SecondAcitivity返回的我们在通过resultCode的值判断处理结果是否成功，最后从data中取值并打印出来. 重新运行程序，在FirstAcitivity界面点击按钮会打开SecondAcitivity然后在SecondAcitivity界面中点击按钮会回到FirstAcitivity，这时查看logcat的打印信息. 如果用户在SecondAcitivity中并不是通过点击按钮而是通过按下Back返回到FirstAcitivity这样数据不就没法返回了吗，我们可以通过在SecondAcitivity中重写onBackPressed()方法来解决问题： 1234567@Override public void onBackPressed() { Intent intent = new Intent(); intent.putExtra(&quot;data_return&quot;, &quot;HelloWorld!&quot;); setResult(RESULT_OK, intent); finish(); } 当用户按下Back键，就回去执行onBackPerssed()方法中的代码. 活动的生命周期 活动的生命周期对任何Android开发者来说都非常重要，只有深入理解了活动的生命周期才可以写出更加连贯流畅地程序， 返回栈 堆栈都已经很熟悉了，经过前面活动的学习，也发现了这一点，Android中的活动是可以层叠的，我们每启动一个新的活动，就会覆盖在原活动之上，然后点击Back 键会销毁最上面的活动，下面的一个活动就会重新显示出来， Android是使用任务Task来管理活动的，一个任务就是一组存放在栈里的活动的集合，这个栈也被称作返回栈Back Stack，栈是一种后进先出的数据结构，在默认情况下，每当我们启动了一个新的活动，他会在返回栈中入栈，并处于栈顶的位置，而每当我们按下Back键或调用finish()方法去销毁一个活动时，处于栈顶的活动会出栈，这时前一个入栈的活动就会重新处于栈顶的位置，系统总会显示处于栈顶的活动给用户， 活动状态 每个活动在其生命周期中最多可能会有4种状态. 运行状态 当一个活动位于返回栈的栈顶时，这时活动就处于运行状态，系统最不愿意回收的就是处于运行状态的活动，因为这会带来非常差的用于体验. 暂停状态 当一个活动不在处于栈顶位置，但仍然可见时，这时活动就进入了暂停状态，处于暂停状态的活动是完全存活的，系统也不愿意去回收这种活动，因为太还是可见的活动，回收可见的东西都会在用户体验方面有不好的影响，只有在内存极低的情况下，系统才会考虑回收这种活动. 停止状态 当一个活动不再处于栈顶位置，并且完全不可见的时候，就进入了停止状态，系统仍然会给这种活动保存相应的状态和成员变量，但是这并不是完全可靠，如果其他地方需要内存，处于停止状态的活动就可能会被系统回收. 销毁活动 当一个活动从返回栈中移除后就变成了销毁状态，系统会最倾向于回收这种状态的活动，从而去保证手机内存充足. 活动的生存期 Acitivity类中定义了7回调方法，覆盖了活动生命周期的每一个环节： onCreate()： 这个方法你已经看到很多次了，每个活动中我们都重写了这个活动，他会在活动第一次被创建的时候调用，你应该在这个方法中完成活动的初始化操作，比如加载布局资源，绑定事件等. onStart()：这个方法在活动有不可见变为可见的时候调用. onResume()：这个方法在活动准备好和用户进行交互的时候调用，此时的活动一定位于返回栈的栈顶，并且处于运行状态. onPause()：这个方法在系统准备去启动给或者恢复另一个活动的时候调用，我们通常会再这个方法中将一些消耗CPU的资源释放掉，以及保存一些关键数据，但这个方法执行速度一定要快，不然会影响到新的栈顶活动的使用. onStop()：这个方法再活动完全不不可见的时候调用，他和onPause()方法的主要区别在于如果启动的新活动是一个对话框式的活动，那么onPause()方法会得到执行，而onStop()方法并不会执行. onDestory()：这个方法在活动被销毁之前调用，之后活动状态将变为销毁状态. onRestart()：这个方法再活动由停止状态变为运行状态之前调用，也就是活动被重新启动了 以上7个方法中除了onRestart()方法，其他方法都是两两相对的，从而又可以将活动分为3种生存期. 完整生存期：活动在onCreate()方法和onDestory()方法之间所经历的，就是完整生存期，一般情况下，一个活动会在onCreate()方法种完成各种初始化操作，而在onDestory()方法种完成释放内存的操作. 可见生存期：活动在onStart()方法和onStop()方法之间所经历的，就是可见生存期，在可见生存期内，活动对于用户总是可见的，即使有可能无法和用户进行交互4 第二章 UI开发点滴TextView 我们在布局文件中添加TextView控件，修改布局文件如下 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:id=&quot;@+id/text_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;This is TextView&quot;/&gt;&lt;/LinearLayout&gt; android:id：给控件定义一个唯一标识符 match_parent：表示让当前控价大小和父布局大小一样 fill_parent：同match_parent 但是现在官方更推荐用match_parent wrap_content：表示让当前控件的大小能够刚好包含住里面的内容 最常用也最难用的控件ListViewListView的简单用法 首先创建一个ListViewTest项目，修改布局文件种根元素为LinearLayout手动添加ListView控件如下 设置宽高都为match_parent这样就占满了整个布局空间 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;ListView android:id=&quot;@+id/list_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;/&gt;&lt;/LinearLayout&gt; 接下来修改MainAcitivity中的代码 我们使用了ArrayAdapter,它可以通过泛型来指定要适配的数据类型，然后在构造函数中把要适配的数据传入，ArrayAdapter有多个构造函数的重载，可以根据情况来选择最合适的，ArrayAdapter中依次传入上下文，ListView子项布局的id以及要适配的数据，这里我们使用了android.R.layout.simple_list_view_1作为ListView子项布局的id，这是一个Android内置的布局文件，里面只有一个TextView可用于简单的显示一段文本， 最后还需要调用ListView的setAdapter()方法将构建好的适配器对象传递进去，这样ListView和数据之间就建立起了关联 123456789101112131415public class MainActivity extends AppCompatActivity { private String[] data = {&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;, &quot;Mango&quot;, &quot;Cherry&quot;, &quot;Pear&quot;, &quot;Mango&quot;,&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;, &quot;Mango&quot;, &quot;Cherry&quot;, &quot;Pear&quot;}; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;&gt;( MainActivity.this, android.R.layout.simple_list_item_1, data); ListView listView = (ListView)findViewById(R.id.list_view); listView.setAdapter(adapter); }} 定制ListView的界面 定义一个实体类，作为ListView适配器的适配类型，新建类Fruit如下 Fruit类中只有两个字段，name表示水果的名字，imageId表示水果对应图片的资源id 123456789101112131415161718public class Fruit { private String name; private int imageId; public Fruit(String name, int imageId) { this.name = name; this.imageId = imageId; } public String getName() { return name; } public int getImageId() { return imageId; }} 新建fruit_item.xml文件，为ListView的子项绑定自定义布局 在这个布局中我们定义了一个ImageView &amp; TextView用于显示水果的图片和水果的名称， 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;ImageView android:id=&quot;@+id/fruit_image&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; /&gt; &lt;TextView android:id=&quot;@+id/fruit_name&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center_vertical&quot; android:layout_marginLeft=&quot;10dp&quot; /&gt;&lt;/LinearLayout&gt; 创建一个自定义的适配器，这个适配器继承自 ArrayAdapter，并将泛型指定Fruit类，新建类FruitAdapter 123456789101112131415161718192021public class FruitAdapter extends ArrayAdapter&lt;Fruit&gt; { private int resourceId; public FruitAdapter(Context context, int textViewResourceId, List&lt;Fruit&gt; objects) { super(context, textViewResourceId, objects); resourceId = textViewResourceId; } @NonNull @Override public View getView(int position, @Nullable View convertView, @NonNull ViewGroup parent) { Fruit fruit = getItem(position); //获取当前项的Fruit实例 View view = LayoutInflater.from(getContext()).inflate(resourceId, parent, false); ImageView fruitImage = (ImageView) view.findViewById(R.id.fruit_image); TextView fruitName = (TextView) view.findViewById(R.id.fruit_name); fruitImage.setImageResource(fruit.getImageId()); fruitName.setText(fruit.getName()); return view; } 重写getView()方法，通过getItem()得到当前项的Fruit实例，然后使用LayoutInflater为子项加载我们传入的布局，这里LayoutInflater的inflater()方法接收3参数，这里就不多去阐述说明参数意义 接下来修改MainAcitivity中的代码为 1234567891011121314151617181920212223242526272829303132333435363738394041public class MainActivity extends AppCompatActivity { private List&lt;Fruit&gt; fruitList = new ArrayList&lt;&gt;(); @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initFruits(); //初始化水果数据 FruitAdapter adapter = new FruitAdapter(MainActivity.this, R.layout.fruit_item, fruitList); ListView listView = (ListView) findViewById(R.id.list_view); listView.setAdapter(adapter); listView.setOnItemClickListener(new AdapterView.OnItemClickListener() { @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) { Fruit fruit = fruitList.get(position); Toast.makeText(MainActivity.this, fruit.getName(),Toast.LENGTH_SHORT).show(); } }); } private void initFruits() { //添加for循环使水果数据充满整个屏幕达到更好的测试效果 for (int i = 0; i &lt; 4; i++) { Fruit apple = new Fruit(&quot;Apple&quot;, R.drawable.apple); fruitList.add(apple); Fruit banana = new Fruit(&quot;Banana&quot;, R.drawable.banana); fruitList.add(banana); Fruit orange = new Fruit(&quot;Orange&quot;, R.drawable.orange); fruitList.add(orange); Fruit cherry = new Fruit(&quot;Cherry&quot;, R.drawable.cherry); fruitList.add(cherry); Fruit mango = new Fruit(&quot;Mango&quot;, R.drawable.mango); fruitList.add(mango); Fruit pear = new Fruit(&quot;Pear&quot;, R.drawable.pear); fruitList.add(pear); } }} initFruits()初始化水果数据，在Fruit类中将水果的图片id和水果名字传入，我们还使用了for循环将所有水果数据添加了4遍这是因为如果只添加一遍的话，这点数据量不足以充满整个屏幕，","link":"/2021/02/25/Android%20Studio%20&&%20Android%20%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"},{"title":"MYSQL笔记","text":"一名沙雕大学生的MYSQL学习笔记 MYSQL[TOC] MYSQL 连接使用二进制方式进入mysql命令提示符下来连接mysql数据库 12Purekit@Mac ~~ mysql -u root -penter password: *输入密码* 接下来就进入到了mysql命令操作中 1mysql&gt; exit; *或者quit* //退出mysql// MYSQL 创建数据库create命令创建数据库1mysql &gt; CREATE DATABASE database_name ； 了解数据库和表12345show databases;//返回当前所有的数据库show tables;//返回当前数据库下可用的表show columns from table_name ;//返回表结构 选择使用数据库USE12mysql &gt; use rootme ;Database changed 执行以上命令后，你就已经成功选择了rootme 数据库，在后续的操作中都会在rootme数据库中执行 MYSQL 数据类型 MySQL中定义数据字段的类型对你数据库的优化是非常重要的。 MySQL支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型。 数值类型 MySQL支持所有标准SQL数值数据类型。这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION)。关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。BIT数据类型保存位字段值，并且支持MyISAM、MEMORY、InnoDB和BDB表。作为SQL标准的扩展，MySQL也支持整数类型TINYINT、MEDIUMINT和BIGINT。下面的表显示了需要的每个整数类型的存储和范围。 类型 大小 范围（有符号） 范围（无符号） 用途 tiyint 1byte (-128，127) (0，255) 小整数值 smallint 2bytes (-32 768，32 767) (0，65 535) 大整数值 mediumint 3bytes (-8 388 608，8 388 607) (0，16 777 215) 大整数值 int or intger 4bytes (-2 147 483 648，2 147 483 647) (0，18 446 744 073 709 551 615) 大整数值 bigint 8bytes (-9,223,372,036,854,775,808，9 223 372 036 854 775 807) 0，(1.175 494 351 E-38，3.402 823 466 E+38) 极大整数值 float 4bytes (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) 0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 单精度 浮点数值 double 8bytes (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 依赖于M和D的值 双精度 浮点数值 decimal 对decimal（m,d)，如果m&gt;d,为，m+2否则d+2 依赖于M和D的值 小数值 日期和时间类型 表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。每个时间类型有一个有效值范围和一个”零”值，当指定不合法的MySQL不能表示的值时使用”零”值。TIMESTAMP类型有专有的自动更新特性，将在后面描述。 类型 大小（bytes） 范围 格式 用途 data 3 1000-01-01/9999-12-31 YYYY-MM-DD 日期值 time 3 ‘-838:59:59’/‘838:59:59’ HH:MM:SS 时间值或持续时间 year 1 1901/2155 YYYY 年份值 datatime 8 1000-01-01 00:00:00/9999-12-31 23:59:59 YYYY-MM-DD HH:MM:SS 混合日期和时间值 timestamp 4 1970-01-01 00:00:00/2038结束时间是第 2147483647 秒，北京时间 2038-1-19 11:14:07 YYYYMMDDHHMMSS 混合日期和时间值，时间戳 字符串类型 字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型。 类型 大小 用途 char 0-255bytes 定长字符串 varchar 0-65535bytes 变长字符串 tinyblob 0-255bytes 不超过255个字符的二进制字符串 tinytext 0-255bytes 段文本字符串 blob 0-65bytes 二进制形式的长文本字符串 text 0-65 535 bytes 长文本数据 mediumblob 0-16 777 215 bytes 二进制形式的中等长度的文本数据 mediumtext 0-16 777 215 bytes 中等长度的文本数据 longblob 0-4 294 967 295 bytes 二进制形式的极大文本数据 longtext 0-4 294 967 295 bytes 极大文本数据 MYSQL 表的创建创建mysql数据表需要以下信息： 表名 表字段名 定义每个表字段 以下为创建mysql数据表_table 的sql通用语法： 1CREATE TABLE table_name (column_name column_type); **create table ** 以下我们将创建数据表root： 12345678910111213Purekit@Mac~~ mysql -u root -pEnter password:*******mysql&gt; use rootme;Database changedmysql&gt; CREATE TABLE root( -&gt; id INT NOT NULL AUTO_INCREMENT, -&gt; name VARCHAR(100) NOT NULL, -&gt; address VARCHAR(100) NOT NULL, -&gt; nowtime DATE, -&gt; PRIMARY KEY (id ) -&gt; )ENGINE=InnoDB DEFAULT CHARSET=utf8;Query OK, 0 rows affected (0.16 sec)mysql&gt; 注意：命令终止符为分号 ; , 如果你不想字段为 NULL 可以设置字段的属性为 NOT NULL， 在操作数据库时如果输入该字段的数据为NULL ，就会报错。 AUTO_INCREMENT定义列为自增的属性，一般用于主键，数值会自动加1。 PRIMARY KEY关键字用于定义列为主键。 您可以使用多列来定义主键，列间以逗号分隔。 ENGINE 设置存储引擎，CHARSET 设置编码。 以下将使用mysql 命令检索创建表结构 123456789describe table_name ; //可以简写为 descorshow create table table_name ; //查看创建表的语句orshow columns from table_name ;//同 desc 命令作用一样 ![image-20200501110909834](/Users/haohongxin/Library/Application Support/typora-user-images/image-20200501110909834.png) MYSQL INSERT INTO以下为向mysql数据表中插入数据通用的insert into table_ name values sql 语法： 1234INSERT INTO table_name (field1 , field2 , .......fieldN ) values (values1 , values2 , .......valuesN);如果数值是字符型，必须使用单引号或者双引号，如“values”。 以下我们向root表中插入三条数据： 1234567891011121314151617purekit@mac~~ mysql -u root -penter password:*******mysql &gt; use rootme ;Database changed mysql &gt; INSERT INTO root -&gt; VALUES -&gt; (1,&quot;学习 PHP&quot;, &quot;菜鸟教程&quot;, NOW());Query OK, 1 rows affected, 1 warnings (0.01 sec)mysql &gt; INSERT INTO root -&gt; VALUES -&gt; (2,&quot;学习 MySQL&quot;, &quot;菜鸟教程&quot;, NOW());Query OK, 1 rows affected, 1 warnings (0.01 sec)mysql &gt; INSERT INTO root -&gt; VALUES -&gt; (3,&quot;JAVA 教程&quot;, &quot;RUNOOB.COM&quot;, NOW());Query OK, 1 rows affected (0.00 sec)mysql &gt; 接下来我们可以通过以下语句查询数据表数据： 读取数据表 select * from root ; 输出结果 ![image-20200501112856984](/Users/haohongxin/Library/Application Support/typora-user-images/image-20200501112856984.png) SELECT 检索 数据库使用select语句进行查询数据 以下为在mysql数据库中查询数据通用的select语法： 1234SELECT column_name,column_nameFROM table_name[WHERE Clause][LIMIT N][ OFFSET M] 查询语句中你可以使用一个或者多个表，表之间使用逗号(,)分割，并使用WHERE语句来设定查询条件 SELECT 命令可以读取一条或者多条记录。 你可以使用星号（*）来代替其他字段，SELECT语句会返回表的所有字段数据 你可以使用 WHERE 语句来包含任何条件 你可以使用 LIMIT 属性来设定返回的记录数 你可以通过OFFSET指定SELECT语句开始查询的数据偏移量。默认情况下偏移量为0 使用样本数据库 websites 12345678910111213mysql&gt; select * from websites;+----+----------+------------------+-------+---------+| id | name | url | alexa | country |+----+----------+------------------+-------+---------+| 1 | Google | www.google.com | 1 | USA || 2 | taobao | www.taobao.com | 13 | CN || 3 | weibo | www.weibo.com | 20 | CN || 4 | facebook | www.facebook.com | 3 | USA || 5 | JD | www.JD.com | 10 | CN |+----+----------+------------------+-------+---------+5 rows in set (0.00 sec)mysql&gt; 检索单个列1select 字段名 from table_name ; 12345678910111213mysql&gt; select name from websites;+----------+| name |+----------+| Google || taobao || weibo || facebook || JD |+----------+5 rows in set (0.00 sec)mysql&gt; 检索多个列12345678910111213mysql&gt; select name , id , country from websites;+----------+----+---------+| name | id | country |+----------+----+---------+| Google | 1 | USA || taobao | 2 | CN || weibo | 3 | CN || facebook | 4 | USA || JD | 5 | CN |+----------+----+---------+5 rows in set (0.00 sec)mysql&gt; 检索所有列 使用通配符（ * ） 检索 1234567891011mysql&gt; select * from websites;+----+----------+------------------+-------+---------+| id | name | url | alexa | country |+----+----------+------------------+-------+---------+| 1 | Google | www.google.com | 1 | USA || 2 | taobao | www.taobao.com | 13 | CN || 3 | weibo | www.weibo.com | 20 | CN || 4 | facebook | www.facebook.com | 3 | USA || 5 | JD | www.JD.com | 10 | CN |+----+----------+------------------+-------+---------+5 rows in set (0.00 sec) 检索不同的行 在表中，一个列可能会包含多个重复值，有时您也许希望仅仅列出不同（distinct）的值。DISTINCT 关键词用于返回唯一不同的值。 SELECT DISTINCT 语法 12SELECT DISTINCT column_name,column_nameFROM table_name; 使用distinct 下面的 SQL 语句仅从 “Websites” 表的 “country” 列中选取唯一不同的值，也就是去掉 “country” 列重复值： 12345678910111213141516171819202122232425mysql&gt; select country from websites;//没有使用 distinct+---------+| country |+---------+| USA || CN || CN || USA || CN |+---------+5 rows in set (0.00 sec)mysql&gt;mysql&gt; select distinct country from websites;+---------+| country |+---------+| USA || CN |+---------+2 rows in set (0.00 sec)mysql&gt; 限制结果 SELECT语句返回所有匹配的行，它们可能是指定表中的每个行。为了返回第一行或前几行，可使用LIMIT子句。 1234567891011mysql&gt; select * from websites -&gt; limit 2;+----+--------+----------------+-------+---------+| id | name | url | alexa | country |+----+--------+----------------+-------+---------+| 1 | Google | www.google.com | 1 | USA || 2 | taobao | www.taobao.com | 13 | CN |+----+--------+----------------+-------+---------+2 rows in set (0.00 sec)mysql&gt; 完全限定表名、字段名12345678910111213141516171819202122232425262728mysql&gt; select websites.name from websites;+----------+| name |+----------+| Google || taobao || weibo || facebook || JD |+----------+5 rows in set (0.00 sec)mysql&gt;mysql&gt; select websites.name from rootme.websites;+----------+| name |+----------+| Google || taobao || weibo || facebook || JD |+----------+5 rows in set (0.00 sec)mysql&gt; ORDER BY 排序检索 我们知道从 MySQL 表中使用 SQL SELECT 语句来读取数据。如果我们需要对读取的数据进行排序，我们就可以使用 MySQL 的 ORDER BY 子句来设定你想按哪个字段哪种方式来进行排序，再返回搜索结果。 以下是SQL SELECT语句使用ORDER BY 子句将查询数据排序后在返回数据： 12SELECT field1, field2,...fieldN FROM table_name1, table_name2...ORDER BY field1 [ASC [DESC][默认 ASC]], [field2...] [ASC [DESC][默认 ASC]] 你可以使用任何字段来作为排序的条件，从而返回排序后的查询结果。 你可以设定多个字段来排序。 你可以使用 ASC 或 DESC 关键字来设置查询结果是按升序或降序排列。 默认情况下，它是按升序排列。 你可以添加 WHERE…LIKE 子句来设置条件。 ASC（升序） 以下将在SQL SELECT语句中使用ORDER BY 子句来读取mysql数据表root中的数据： 默认是升序排列 1234567891011121314mysql&gt; select * from websites order by id asc ;+----+----------+------------------+-------+---------+| id | name | url | alexa | country |+----+----------+------------------+-------+---------+| 1 | Google | www.google.com | 1 | USA || 2 | taobao | www.taobao.com | 13 | CN || 3 | weibo | www.weibo.com | 20 | CN || 4 | facebook | www.facebook.com | 3 | USA || 5 | JD | www.JD.com | 10 | CN |+----+----------+------------------+-------+---------+5 rows in set (0.00 sec)mysql&gt; DESC(降序）12345678910111213mysql&gt; select * from websites order by id desc ;+----+----------+------------------+-------+---------+| id | name | url | alexa | country |+----+----------+------------------+-------+---------+| 5 | JD | www.JD.com | 10 | CN || 4 | facebook | www.facebook.com | 3 | USA || 3 | weibo | www.weibo.com | 20 | CN || 2 | taobao | www.taobao.com | 13 | CN || 1 | Google | www.google.com | 1 | USA |+----+----------+------------------+-------+---------+5 rows in set (0.00 sec)mysql&gt; 按多个列排序1234567891011121314mysql&gt; select * from websites -&gt; order by name ,id;+----+----------+------------------+-------+---------+| id | name | url | alexa | country |+----+----------+------------------+-------+---------+| 4 | facebook | www.facebook.com | 3 | USA || 1 | Google | www.google.com | 1 | USA || 5 | JD | www.JD.com | 10 | CN || 2 | taobao | www.taobao.com | 13 | CN || 3 | weibo | www.weibo.com | 20 | CN |+----+----------+------------------+-------+---------+5 rows in set (0.00 sec)mysql&gt; WHERE 过滤数据 我们知道从mysql表中使用**sql select **语句来读取数据 如需有条件地从表中选取数据，可将where子句添加到select 语句中 以下是利用select where 从数据表中读取数据的通用语法 12SELECT field1, field2,...fieldN FROM table_name1, table_name2...[WHERE condition1 [AND [OR]] condition2..... 查询语句中你可以使用一个或者多个表，表之间使用逗号**,** 分割，并使用WHERE语句来设定查询条件。 你可以在 WHERE 子句中指定任何条件。 你可以使用 AND 或者 OR 指定一个或多个条件。 WHERE 子句也可以运用于 SQL 的 DELETE 或者 UPDATE 命令。 WHERE 子句类似于程序语言中的 if 条件，根据 MySQL 表中的字段值来读取指定的数据。 WHERE 可使用操作符 以下为操作符列表，可用于 WHERE 子句中下表中实例假定 A 为 10, B 为 20 操作符 描述 实例 = 等号，检测两个值是否相等，如果相等返回true （ A = B ）返回false &lt;&gt; , != 不等于，检测两个值是否相等，如果不相等返回true （ A != B ) 返回true &gt; 大于号，检测左边的值是否大于右边的值如果左边的值大于右边的值返回true （ A &gt; B ) 返回false &gt;= 大于等于号，检测左边的值是够大于获等于右边的值，如果左边的值大于或等于右边的值返回true （ A &gt;= B ) 返回true &lt; 小于号，检测左边的值是否小于右边的值如果小于返回true （ A &lt; B ) 返回ture &lt;= 小于等于号，检测左边的是否小于或者等于右边的值如果成立返回ture （ A &lt;= B ) 返回ture between 在指定的两个值之间 A–B之间 返回 A–B 之间的所有数据 检查单个值 mysql执行匹配时不区分大小写 12345678910mysql&gt; select * from websites -&gt; where id = 4; //返回 id 列等于 4 数据+----+----------+------------------+-------+---------+| id | name | url | alexa | country |+----+----------+------------------+-------+---------+| 4 | facebook | www.facebook.com | 3 | USA |+----+----------+------------------+-------+---------+1 row in set (0.00 sec)mysql&gt; 空值检查（NULL） NULL 无值 ，他与字段包含0、空字符串仅仅包含空格不同 SELECT语句有一个特殊的WHERE子句，可用来检查具有NULL值的列。 这个WHERE子句就是IS NULL子句。： 使用binary区分检索大小写 **MySQL 的 **WHERE子句的字符串比较是不区分大小写的。 你可以使用 BINARY 关键字来设定 WHERE 子句的字符串比较是区分大小写的. 1234567891011121314BINARY 关键字mysql&gt; select * from root where binary address = 'runoob.com';Empty set (0.00 sec)mysql&gt; select * from root where binary address = 'RUNOOB.COM' ;+----+---------------+------------+------------+| id | name | address | nowtime |+----+---------------+------------+------------+| 3 | JAVA 教程 | RUNOOB.COM | 2020-05-01 || 4 | 学习 Python | RUNOOB.COM | 2020-05-01 |+----+---------------+------------+------------+2 rows in set (0.00 sec)mysql&gt; 实例中使用了 BINARY 关键字，是区分大小写的，所以 address=’runoob.com’ 的查询条件是没有数据的. AND &amp; OR 操作符 AND &amp; OR 运算符用于基于一个以上的条件对记录进行过滤。 如果第一个条件和第二个条件都成立，则 AND 运算符显示一条记录。 如果第一个条件和第二个条件中只要有一个成立，则 OR 运算符显示一条记录。 AND 添加检索的附加条件 and（和） 123456789101112mysql&gt; select * from websites -&gt; where country = 'USA' -&gt; and alexa &lt; 10 ;+----+----------+------------------+-------+---------+| id | name | url | alexa | country |+----+----------+------------------+-------+---------+| 1 | Google | www.google.com | 1 | USA || 4 | facebook | www.facebook.com | 3 | USA |+----+----------+------------------+-------+---------+2 rows in set (0.00 sec)mysql&gt; OR 添加检索的附加条件or（或者） 123456789101112131415mysql&gt; select * from websites -&gt; where country = 'CN' -&gt; or country = 'USA' ;+----+----------+------------------+-------+---------+| id | name | url | alexa | country |+----+----------+------------------+-------+---------+| 1 | Google | www.google.com | 1 | USA || 2 | taobao | www.taobao.com | 13 | CN || 3 | weibo | www.weibo.com | 20 | CN || 4 | facebook | www.facebook.com | 3 | USA || 5 | JD | www.JD.com | 10 | CN |+----+----------+------------------+-------+---------+5 rows in set (0.00 sec)mysql&gt; 计算次序 AND&amp;OR 当and or操作符在一个where语句中使用时就要考虑到计算次序的问题 and 要比or优先 所以先进行and操作符工作 在进行or操作符工作 1234567891011121314mysql&gt; select * from schools -&gt; where type = 985 or type = 211 and address = 'Beijing' ;+----+--------------------+------+---------+------+| id | name | type | address | area |+----+--------------------+------+---------+------+| 1 | 北京大学 | 985 | beijing | 7000 || 2 | 清华大学 | 985 | Beijing | 5886 || 3 | 北京科技大学 | 211 | Beijing | 1200 || 5 | 电子科技大学 | 985 | Chengdu | 5000 || 6 | 武汉大学 | 985 | Wuhan | 5195 |+----+--------------------+------+---------+------+5 rows in set (0.00 sec)mysql&gt; 因为计算优先级的原因所以要进行综合检索的话要用（） 分隔开附加条件 1234567891011121314mysql&gt; select * from websites -&gt; where alexa &gt; 1 -&gt; and ( country = 'CN' or country = 'USA' );+----+----------+------------------+-------+---------+| id | name | url | alexa | country |+----+----------+------------------+-------+---------+| 2 | taobao | www.taobao.com | 13 | CN || 3 | weibo | www.weibo.com | 20 | CN || 4 | facebook | www.facebook.com | 3 | USA || 5 | JD | www.JD.com | 10 | CN |+----+----------+------------------+-------+---------+4 rows in set (0.00 sec)mysql&gt; IN 操作符 圆括号在WHERE子句中还有另外一种用法。IN操作符用来指定条件范 围，范围中的每个条件都可以进行匹配。IN取合法值的由逗号分隔的清 单，全都括在圆括号中。 WHERE子句中用来指定要匹配值的清单的关键字，功能与OR 相当。 12345678910111213mysql&gt; select * from schools -&gt; where address in ('wuhan' , 'Beijing');+----+--------------------+------+---------+------+| id | name | type | address | area |+----+--------------------+------+---------+------+| 1 | 北京大学 | 985 | beijing | 7000 || 2 | 清华大学 | 985 | Beijing | 5886 || 3 | 北京科技大学 | 211 | Beijing | 1200 || 6 | 武汉大学 | 985 | Wuhan | 5195 |+----+--------------------+------+---------+------+4 rows in set (0.00 sec)mysql&gt; NOT 操作符 WHERE子句中的NOT操作符有且只有一个功能，那就是否定它之后所 跟的任何条件。 1234567891011mysql&gt; select * from schools -&gt; where address not in('wuhan','Beijing');+----+--------------------+------+-----------+------+| id | name | type | address | area |+----+--------------------+------+-----------+------+| 4 | 郑州大学 | 211 | Zhengzhou | 5700 || 5 | 电子科技大学 | 985 | Chengdu | 5000 |+----+--------------------+------+-----------+------+2 rows in set (0.00 sec)mysql&gt; 为什么使用NOT？对于简单的WHERE子句，使用NOT确实没有什么优 势。但在更复杂的子句中，NOT是非常有用的。例如，在与IN操作符联合 使用时，NOT使找出与条件列表不匹配的行非常简单。 MYSQL UPDATE 如果我们需要修改或更新 MySQL 中的数据，我们可以使用 SQL UPDATE 命令来操作。 以下是 UPDATE 命令修改 MySQL 数据表数据的通用 SQL 语法： 123UPDATE table_nameSET column1=value1,column2=value2,...WHERE some_column=some_value; 你可以同时更新一个或多个字段。 你可以在 WHERE 子句中指定任何条件。 你可以在一个单独表中同时更新数据。 SQL UPDATE 语句： 12345678910111213mysql&gt; update root set name = '学习 C++' where id = 3 ;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; select * from root where id = 3 ;+----+------------+------------+------------+| id | name | address | nowtime |+----+------------+------------+------------+| 3 | 学习 C++ | RUNOOB.COM | 2020-05-01 |+----+------------+------------+------------+1 row in set (0.00 sec)mysql&gt; 警告：在更新记录时要格外小心！在上面的实例中，如果我们省略了 WHERE 子句，如下所示： 12UPDATE WebsitesSET alexa='5000', country='USA' 执行以上代码会将 Websites 表中所有数据的 alexa 改为 5000，country 改为 USA。执行没有 WHERE 子句的 UPDATE 要慎重，再慎重。 MYSQL DELETE 你可以使用 SQL 的 DELETE FROM 命令来删除 MySQL 数据表中的记录。 以下是 SQL DELETE 语句从 MySQL 数据表中删除数据的通用语法： 12DELETE FROM table_nameWHERE some_column=some_value; 如果没有指定 WHERE 子句，MySQL 表中的所有记录将被删除。 你可以在 WHERE 子句中指定任何条件 您可以在单个表中一次性删除记录。 DELETE 语句： 从命令行中删除数据 1234mysql&gt; use rootme;Database changedmysql&gt; delete from root where id = 3 ;Query OK, 1 row affected (0.23 sec) 删除所有数据 您可以在不删除表的情况下，删除表中所有的行。这意味着表结构、属性、索引将保持不变： 12345DELETE FROM table_name;ORDELETE * FROM table_name; 注释：在删除记录时要格外小心！因为您不能重来！ LIKE 通配符过滤 SQLLIKE 子句中使用百分号 **%**字符来表示任意字符，类似于UNIX或正则表达式中的星号 *****。如果没有使用百分号 %, LIKE 子句与等号 = 的效果是一样的 (我自己的理解相当于模糊搜索的意思) 以下是 **SQL SELECT **语句使用 LIKE 子句从数据表中读取数据的通用语法： 123SELECT column_name(s)FROM table_nameWHERE column_name LIKE pattern; 你可以在 WHERE 子句中指定任何条件。 你可以在 WHERE 子句中使用LIKE子句。 你可以使用LIKE子句代替等号 **=**。 LIKE 通常与 % 一同使用，类似于一个元字符的搜索。 你可以使用 AND 或者 OR 指定一个或多个条件。 你可以在 DELETE 或 UPDATE 命令中使用 WHERE…LIKE 子句来指定条件。 % 替代字符检索 以下是我们将root表中获取的address字段中以com结尾的所有数据记录： 123456789101112mysql&gt; use rootme;Database changedmysql&gt; select * from root where address like '%COM' ;+----+---------------+------------+------------+| id | name | address | nowtime |+----+---------------+------------+------------+| 3 | 学习 C++ | RUNOOB.COM | 2020-05-01 || 4 | 学习 Python | RUNOOB.COM | 2020-05-01 |+----+---------------+------------+------------+2 rows in set (0.00 sec)mysql&gt; like 可用通配符 通配符可用于替代字符串中的任何其他字符。在 SQL 中，通配符与 SQL LIKE 操作符一起使用。SQL 通配符用于搜索表中的数据。 通配符 描述 % 替代0个或多个字符 _ 替代一个字符 [charlist] 字符列中任何单一字符 [^charlist] or [!charlist] 不再字符列中的任何单一字符 · UNION MySQL UNION 操作符用于连接两个以上的 SELECT 语句的结果组合到一个结果集合中。多个 SELECT 语句会删除重复的数据。 UNION 操作符语法：1234567SELECT expression1, expression2, ... expression_nFROM tables[WHERE conditions]UNION [ALL | DISTINCT]SELECT expression1, expression2, ... expression_nFROM tables[WHERE conditions]; 参数 expression1, expression2, … expression_n: 要检索的列。 tables: 要检索的数据表。 WHERE conditions: 可选， 检索条件。 DISTINCT: 可选，删除结果集中重复的数据。默认情况下 UNION 操作符已经删除了重复数据，所以 DISTINCT 修饰符对结果没啥影响。 ALL: 可选，返回所有结果集，包含重复数据。 UNION 语句：用于将不同表中相同列中查询的数据展示出来；（不包括重复数据） UNION ALL 语句：用于将不同表中相同列中查询的数据展示出来；（包括重复数据） 演示数据库 在本演示中我们将使用rootme数据库 下面选自websites表的数据： 12345678910111213mysql&gt; select * from websites ;+----+----------+------------------+-------+--------+| id | name | url | alexa |country |+----+----------+------------------+-------+--------+| 1 | Google | www.google.com | 1 | USA || 2 | taobao | www.taobao.com | 13 | CN || 3 | weibo | www.weibo.com | 20 | CN || 4 | facebook | www.facebook.com | 3 | USA || 5 | JD | www.JD.com | 10 | CN |+----+----------+------------------+-------+--------+5 rows in set (0.00 sec)mysql&gt; 下面是apps表的数据： 1234567891011mysql&gt; select * from apps;+----+----------+----------------+--------+| id | app_name | url |country |+----+----------+----------------+--------+| 1 | QQ | im.qq.com | CN || 2 | weibo | www.weibo.com | CN || 3 | weixin | www.weixin.com | CN |+----+----------+----------------+--------+3 rows in set (0.00 sec)mysql&gt; UNION 下面的 SQL 语句从 “Websites” 和 “apps” 表中选取所有不同的country（只有不同的值）： 12345678910111213mysql&gt; select country from websites -&gt; union -&gt; select country from apps -&gt; order by country ;+--------+|country |+--------+| CN || USA |+--------+2 rows in set (0.00 sec)mysql&gt; **注释:**UNION 不能用于列出两个表中所有的country。如果一些网站和APP UNION ALL 下面的 SQL 语句使用 UNION ALL 从 “Websites” 和 “apps” 表中选取所有的country（也有重复的值）： 12345678910111213141516171819mysql&gt; select country from websites -&gt; union all -&gt; select country from apps -&gt; order by country ;+--------+|country |+--------+| CN || CN || CN || CN || CN || CN || USA || USA |+--------+8 rows in set (0.00 sec)mysql&gt; 带有WHERE的 UNION ALL 下面的 SQL 语句使用 UNION ALL 从 “Websites” 和 “apps” 表中选取所有的中国(CN)的数据（也有重复的值）： 12345678910111213141516171819mysql&gt; select country ,name from websites -&gt; where country = 'CN' -&gt; union all -&gt; select country ,name from apps -&gt; where country = 'CN' -&gt; order by country;+---------+--------+| country | name |+---------+--------+| CN | taobao || CN | weibo || CN | JD || CN | QQ || CN | weibo || CN | weixin |+---------+--------+6 rows in set (0.00 sec)mysql&gt; 正则表达式(REGEXP) 正则表达式是一组由字母和符号组成的特殊文本, 它可以用来从文本中找出满足你想要的格式的句子. 一个正则表达式是在一个主体字符串中从左到右匹配字符串时的一种样式. “Regular expression”这个词比较拗口, 我们常使用缩写的术语”regex”或”regexp”. 正则表达式可以从一个基础字符串中根据一定的匹配模式替换文本中的字符串、验证表单、提取字符串等等. 想象你正在写一个应用, 然后你想设定一个用户命名的规则, 让用户名包含字符,数字,下划线和连字符,以及限制字符的个数,好让名字看起来没那么丑. 我们使用以下正则表达式来验证一个用户名: ![image-20200504151108460](/Users/haohongxin/Library/Application Support/typora-user-images/image-20200504151108460.png) 基本匹配正则表达式其实就是在执行搜索时的格式, 它由一些字母和数字组合而成. 例如: 一个正则表达式 the, 它表示一个规则: 由字母t开始,接着是h,再接着是e. ![image-20200504155636791](/Users/haohongxin/Library/Application Support/typora-user-images/image-20200504155636791.png) 正则表达式123匹配字符串123. 它逐个字符的与输入的正则表达式做比较. 正则表达式是大小写敏感的, 所以The不会匹配the. ![image-20200504155708420](/Users/haohongxin/Library/Application Support/typora-user-images/image-20200504155708420.png) 简单匹配演示 12345678910mysql&gt; select * from websites -&gt; where name regexp 'Goo';+----+--------+----------------+-------+---------+| id | name | url | alexa | country |+----+--------+----------------+-------+---------+| 1 | Google | www.google.com | 1 | USA |+----+--------+----------------+-------+---------+1 row in set (0.00 sec) 元字符 正则表达式主要依赖于元字符. 元字符不代表他们本身的字面意思, 他们都有特殊的含义. 一些元字符写在方括号中的时候有一些特殊的意思. 以下是一些元字符的介绍: 元字符 描述 . 句号匹配但个字符除了换行符 [ ] 字符种类 匹配方括号内的任意字符 [^ ] 否定的字符种类，匹配除了方括号内的任意字符 * 匹配 &gt;= 个重复在 * 之间的字符 + 匹配 &gt;= 1 个重复在 + 号之间的字符 ? 标记 ？ 之前的字符为可选 {n,m} 匹配 num 个中括号之前的字符（n &lt;= num &lt;= m) {xyz} 字符集，匹配与xyz完全相等字符串（大小写很敏感 要区分好） | ’ 或 ‘ 运算符匹配符号之间前或后的字符 \\ 转义字符 用于匹配一些保留的字符[ ] ( ) { } . * + ? ^ $ \\ ^ 从开始行开始匹配 &amp; 从末端开始匹配 点运算符 ..是元字符中最简单的例子. .匹配任意单个字符, 但不匹配换行符. 例如, 表达式.ar匹配一个任意字符后面跟着是a和r的字符串. ![image-20200504155745504](/Users/haohongxin/Library/Application Support/typora-user-images/image-20200504155745504.png) 简单匹配演示 12345678910mysql&gt; select * from root -&gt; where name regexp '.PHP' ;+----+------------+--------------+------------+| id | name | address | nowtime |+----+------------+--------------+------------+| 1 | 学习 PHP | 菜鸟教程 | 2020-05-01 |+----+------------+--------------+------------+1 row in set (0.00 sec)mysql&gt; 字符集 [ ]字符集也叫做字符类. 方括号用来指定一个字符集. 在方括号中使用连字符来指定字符集的范围. 在方括号中的字符集不关心顺序. 例如, 表达式[Tt]he 匹配 the 和 The. ![image-20200504160603979](/Users/haohongxin/Library/Application Support/typora-user-images/image-20200504160603979.png) 方括号的句号就表示句号. 表达式 ar[.] 匹配 ar.字符串 ![image-20200504160641950](/Users/haohongxin/Library/Application Support/typora-user-images/image-20200504160641950.png) 简单检索演示 1234567891011121314mysql&gt; select name ,url from websites -&gt; where url regexp '[.]co';+----------+------------------+| name | url |+----------+------------------+| Google | www.google.com || taobao | www.taobao.com || weibo | www.weibo.com || facebook | www.facebook.com || JD | www.JD.com |+----------+------------------+5 rows in set (0.00 sec)mysql&gt; 否定字符集[ ^ ]一般来说 ^ 表示一个字符串的开头, 但它用在一个方括号的开头的时候, 它表示这个字符集是否定的. 例如, 表达式[^c]ar 匹配一个后面跟着ar的除了c的任意字符. ![image-20200504202133675](/Users/haohongxin/Library/Application Support/typora-user-images/image-20200504202133675.png) 简单检索演示 1234567891011121314151617181920mysql&gt; select * from apps ;+----+--------+----------------+---------+| id | name | url | country |+----+--------+----------------+---------+| 1 | QQ | im.qq.com | CN || 2 | weibo | www.weibo.com | CN || 3 | weixin | www.weixin.com | CN |+----+--------+----------------+---------+3 rows in set (0.01 sec)mysql&gt; select * from apps -&gt; where name regexp 'wei[^xin]';+----+--------+---------------+---------+| id | name | url | country |+----+--------+---------------+---------+| 2 | weibo | www.weibo.com | CN |+----+--------+---------------+---------+1 row in set (0.00 sec)mysql&gt; 重复次数*** 号 ** *号匹配 在*之前的字符出现大于等于0次. 例如, 表达式 a* 匹配以0或更多个a开头的字符, 因为有0个这个条件, 其实也就匹配了所有的字符. 表达式[a-z]* 匹配一个行中所有以小写字母开头的字符串. ![image-20200504203357614](/Users/haohongxin/Library/Application Support/typora-user-images/image-20200504203357614.png) *字符和.字符搭配可以匹配所有的字符.*. *和表示匹配空格的符号\\s连起来用, 如表达式\\s*cat\\s*匹配0或更多个空格开头和0或更多个空格结尾的cat字符串. ![image-20200504203911726](/Users/haohongxin/Library/Application Support/typora-user-images/image-20200504203911726.png) + 号 +号匹配+号之前的字符出现 &gt;=1 次个字符. 例如表达式c.+t 匹配以首字母c开头以t结尾,中间跟着任意个字符的字符串. ![image-20200504204014305](/Users/haohongxin/Library/Application Support/typora-user-images/image-20200504204014305.png) ? 号 在正则表达式中元字符 ? 标记在符号前面的字符为可选, 即出现 0 或 1 次. 例如, 表达式 [T]?he 匹配字符串 he 和 The ![image-20200504204056836](/Users/haohongxin/Library/Application Support/typora-user-images/image-20200504204056836.png) ![image-20200504204147595](/Users/haohongxin/Library/Application Support/typora-user-images/image-20200504204147595.png) {}号在正则表达式中 {} 是一个量词, 常用来一个或一组字符可以重复出现的次数. 例如, 表达式 [0-9]{2,3} 匹配 2～3 位 0～9 的数字. ![image-20200504204247694](/Users/haohongxin/Library/Application Support/typora-user-images/image-20200504204247694.png) 我们可以省略第二个参数. 例如, [0-9]{2,} 匹配至少两位 0~9 的数字. 如果逗号也省略掉则表示重复固定的次数. 例如, [0-9]{3} 匹配3位数字 ![image-20200504204329859](/Users/haohongxin/Library/Application Support/typora-user-images/image-20200504204329859.png) ![image-20200504204339945](/Users/haohongxin/Library/Application Support/typora-user-images/image-20200504204339945.png) (...)特征标群特征标群是一组写在 (...) 中的子模式. 例如之前说的 {} 是用来表示前面一个字符出现指定次数. 但如果在 {} 前加入特征标群则表示整个标群内的字符重复 N 次. 例如, 表达式 (ab)* 匹配连续出现 0 或更多个 ab.* *我们还可以在 () 中用或字符 | 表示或. 例如, (c|g|p)ar 匹配 car 或 gar 或 par. ![image-20200504204646157](/Users/haohongxin/Library/Application Support/typora-user-images/image-20200504204646157.png) | 或运算或运算符就表示或, 用作判断条件. 例如 (T|t)he|car 匹配 (T|t)he 或 car. ![image-20200504205650455](/Users/haohongxin/Library/Application Support/typora-user-images/image-20200504205650455.png) 转码特殊字符反斜线 \\ 在表达式中用于转码紧跟其后的字符. 用于指定 { } [ ] / \\ + * . $ ^ | ? 这些特殊字符. 如果想要匹配这些特殊字符则要在其前面加上反斜线 \\&lt; 例如 . 是用来匹配除换行符外的所有字符的. 如果想要匹配句子中的 . 则要写成 \\. 以下这个例子 \\.?是选择性匹配. ![image-20200504205903859](/Users/haohongxin/Library/Application Support/typora-user-images/image-20200504205903859.png) 锚点^ $在正则表达式中，想要匹配开头的或者结尾的字符串就要使用到锚点 ^ 指定开头$指定结尾 ^ ^ 用来检查匹配的字符串是否在所匹配字符串的开头. 例如, 在 abc 中使用表达式 ^a 会得到结果 a. 但如果使用 ^b 将匹配不到任何结果. 因为在字符串 abc 中并不是以 b 开头. 例如, ^(T|t)he 匹配以 The 或 the 开头的字符串. ![image-20200504210511980](/Users/haohongxin/Library/Application Support/typora-user-images/image-20200504210511980.png) ![image-20200504210527180](/Users/haohongxin/Library/Application Support/typora-user-images/image-20200504210527180.png) $ 号 同理于 ^ 号, $ 号用来匹配字符是否是最后一个. 例如, (at\\.)$ 匹配以 at. 结尾的字符串. ![image-20200504211527714](/Users/haohongxin/Library/Application Support/typora-user-images/image-20200504211527714.png) ![image-20200504211540483](/Users/haohongxin/Library/Application Support/typora-user-images/image-20200504211540483.png) 简写字符集 简写 描述 . 除去换行符外的所有字符 \\w 匹配所有字母数字，等同于：[a-zA-Z0-9_] \\W 匹配所有非字母数字，即符号，等同于 ：[ ^ \\w] \\d 匹配数字：[0-9] \\D 匹配非数字：[ ^ \\d] \\s 匹配所有空格字符, 等同于: [ \\t \\n \\f \\r \\p {Z} ] \\S 匹配所有非空格字符: [^\\s] \\f 匹配一个换页符 \\n 匹配一个换行符 \\r 匹配一个回车符 \\t 匹配一个制表符 \\v 匹配一个垂直制表符 \\p 匹配 CR/LF (等同于 \\r\\n)，用来匹配 DOS 行终止符 前后关联约束?=…` 前置约束(存在) ?=... 前置约束(存在), 表示第一部分表达式必须跟在 ?=...定义的表达式之后. 返回结果只满足第一部分表达式. 定义一个前置约束(存在)要使用 (). 在括号内部使用一个问号和等号: (?=...). 前置约束的内容写在括号中的等号后面. 例如, 表达式 (T|t)he(?=\\sfat) 匹配 The 和 the, 在括号中我们又定义了前置约束(存在) (?=\\sfat) ,即 The 和 the 后面 ![image-20200504215141378](/Users/haohongxin/Library/Application Support/typora-user-images/image-20200504215141378.png) ?&lt;= ... 后置约束-存在 后置约束-存在 记作(?&lt;=...) 用于筛选所有匹配结果, 筛选条件为 其前跟随着定义的格式. 例如, 表达式 (?&lt;=(T|t)he\\s)(fat|mat) 匹配 fat 和 mat, 且其前跟着 The 或 the. ![image-20200504215301345](/Users/haohongxin/Library/Application Support/typora-user-images/image-20200504215301345.png) ? 后置约束-排除 后置约束-排除 记作 (? 用于筛选所有匹配结果, 筛选条件为 其前不跟着定义的格式. 例如, 表达式 (? 匹配 cat, 且其前不跟着 The 或 the. 标志 标志 描述 i 忽略大小写 g 全局搜索 m 多行的: 锚点元字符 ^ $ 工作范围在每行的起始. 忽略大小写 (Case Insensitive) 修饰语 i 用于忽略大小写. 例如, 表达式 /The/gi 表示在全局搜索 The, 在后面的 i 将其条件修改为忽略大小写, 则变成搜索 the 和 The, g 表示全局搜索. ![image-20200504215640289](/Users/haohongxin/Library/Application Support/typora-user-images/image-20200504215640289.png) ![image-20200504215650541](/Users/haohongxin/Library/Application Support/typora-user-images/image-20200504215650541.png) 全局搜索 (Global search) 修饰符 g 常用语执行一个全局搜索匹配, 即(不仅仅返回第一个匹配的, 而是返回全部). 例如, 表达式 /.(at)/g 表示搜索 任意字符(除了换行) + at, 并返回全部结果. ![image-20200504215729995](/Users/haohongxin/Library/Application Support/typora-user-images/image-20200504215729995.png) ![image-20200504215740333](/Users/haohongxin/Library/Application Support/typora-user-images/image-20200504215740333.png) 多行修饰符 (Multiline) 多行修饰符 m 常用语执行一个多行匹配. 像之前介绍的 (^,$) 用于检查格式是否是在待检测字符串的开头或结尾. 但我们如果想要它在每行的开头和结尾生效, 我们需要用到多行修饰符 m. 例如, 表达式 /at(.)?$/gm 表示在待检测字符串每行的末尾搜索 at后跟一个或多个 . 的字符串, 并返回全部结果. ![image-20200504215822817](/Users/haohongxin/Library/Application Support/typora-user-images/image-20200504215822817.png) ![image-20200504215834224](/Users/haohongxin/Library/Application Support/typora-user-images/image-20200504215834224.png) 创建计算字段拼接字段 字段（field） 基本上与列（column）的意思相同，经常互换使 用，不过数据库列一般称为列，而术语字段通常用在计算字段的 连接上。 拼接（concatenate） 将值联结到一起构成单个值。 解决办法是把两个列拼接起来。在MySQL的SELECT语句中，可使用 Concat()函数来拼接两个列。 Concat Concat() 拼接串， 即把多个串连接起来形成一个较长的串。 123456789101112131415mysql&gt; select concat(name ,'(',country,')') -&gt; from websites -&gt; order by name ;+-------------------------------+| concat(name ,'(',country,')') |+-------------------------------+| facebook(USA) || Google(USA) || JD(CN) || taobao(CN) || weibo(CN) |+-------------------------------+5 rows in set (0.00 sec)mysql&gt; RTrim（ ） &amp; LTRim（ ） RTrim()函数去掉值右边的所有空格。通过使用RTrim()，各个 列都进行了整理。相反LTrim去掉左边的空格 以及Trim（）去掉左右两边的空格 12345678910111213141516171819select concat(rtrim(name) ,'(',rtrim(country),')')from websites order by name ;mysql&gt; select concat(rtrim(name) ,'(',rtrim(country),')') -&gt; from websites -&gt; order by name ;+---------------------------------------------+| concat(rtrim(name) ,'(',rtrim(country),')') |+---------------------------------------------+| facebook(USA) || Google(USA) || JD(CN) || taobao(CN) || weibo(CN) |+---------------------------------------------+5 rows in set (0.01 sec)mysql&gt; 使用别名 从上面的concat拼接可以看出但是新的计算返回的列名 实际上没有名字他只是一个值为了解决这个问题 sql支持列别名 别名（alias）是一个字段或值的替换名。别名用AS关键字赋予 123456789101112131415mysql&gt; select concat(name ,'(',country,')') as app_name -&gt; from websites -&gt; order by name;+---------------+| app_name |+---------------+| facebook(USA) || Google(USA) || JD(CN) || taobao(CN) || weibo(CN) |+---------------+5 rows in set (0.00 sec)mysql&gt; 分析上面的语言可以看出之前的拼接语句被别名app_name 代替 执行算术计算 计算字段的另一常见用途是对检索出的数据进行算术计算。 算术操作符 操作符 描述 + 加 - 减 * 乘 / 除 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657mysql&gt; create table jisuan( -&gt; number_1 int(8) not null, -&gt; number_2 int(9) not null, -&gt; primary key(number_1) -&gt; ) charset = utf8;Query OK, 0 rows affected, 3 warnings (0.01 sec)mysql&gt; desc jisuan;+----------+------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+------+------+-----+---------+-------+| number_1 | int | NO | PRI | NULL | || number_2 | int | NO | | NULL | |+----------+------+------+-----+---------+-------+2 rows in set (0.01 sec)mysql&gt; insert into jisuan values -&gt; (8,4), -&gt; (3,5), -&gt; (5,2), -&gt; (3,7); ERROR 1062 (23000): Duplicate entry '3' for key 'jisuan.PRIMARY'//这里说是主键数值重复了 那我们删除主键在测试mysql&gt; alter table jisuan drop primary key; //删除主键Query OK, 0 rows affected (0.02 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; insert into jisuan values (8,4), (3,5), (5,2), (3,7);Query OK, 4 rows affected (0.01 sec)Records: 4 Duplicates: 0 Warnings: 0//成功插入mysql&gt; select number_1 * number_2 from jisuan // 使用 * 号计算 -&gt; where number_1 = 3 -&gt; order by number_1 ;+---------------------+| number_1 * number_2 |+---------------------+| 15 || 21 |+---------------------+2 rows in set (0.01 sec)mysql&gt; select number_1 + number_2 from jisuan //使用 + 号进行加计算 -&gt; order by number_1;+---------------------+| number_1 + number_2 |+---------------------+| 8 || 10 || 7 || 12 |+---------------------+4 rows in set (0.01 sec)mysql&gt; 使用数据处理函数文本处理函数 函数 描述 left ( ) 返回串左边的字符 right ( ) 返回串右边的字符 lrtrim（） 去掉串左边的空格 rtrim（） 去掉串右边的空格 lower（） 将串转换为小写 upper（） 将串转换为大写 length（） 返回串的长度 locate（） 找出串的一个字串 soundex （） 返回串的soundex值（匹配所有发音类似的数据名） substring（） 返回子串的字符 的SOUNDEX需要做进一步的解释。SOUNDEX是一个将任何文 本串转换为描述其语音表示的字母数字模式的算法。SOUNDEX考虑了类似 的发音字符和音节， 使得能对串进行发音比较而不是字母比较。 1234567891011121314mysql&gt; select upper(name) as app_name //使用 upper 函数使字符转换为大写 -&gt; from websites ;+----------+| app_name |+----------+| GOOGLE || TAOBAO || WEIBO || FACEBOOK || JD |+----------+5 rows in set (0.01 sec)mysql&gt; 日期和时间处理函数 表中例举了常用的日期和时间处理函数 函数 描述 AddDate() 增加一个日期（天、周等） AddTime() 增加一个时间（时、分等） CurDate() 返回当前日期 Curtime() 返回当前时间 Date() 返回日期时间的日期部分 DateDiff() 计算两个日期之差 Date_Add() 高度灵活的日期运算函数 Date_Format() 返回一个格式化的日期或时间串 Day() 返回一个日期的天数部分 DayOfWeek() 对于一个日期，返回对应的星期几 Hour() 返回一个时间的小时部分 Minute() 返回一个时间的分钟部分 Month() 返回一个日期的月份部分 Now() 返回当前日期和时间 Second() 返回一个时间的秒部分 Time() 返回一个日期时间的时间部分 Year() 返回一个日期的年份部分 使用employees表进行演示 employees 表可能有点复杂 后面我们会把本书的建表语句以及数据库导出打包 1234567891011121314151617181920212223242526272829303132333435363738394041424344mysql&gt; select * from employees;+--------+-----------+-----+--------------+-----------+--------------+------------+-------+------------+------+-----+| E_ID | E_name | sex | Professional | education | Political | birth | marry | Gz_time | D_id | bz |+--------+-----------+-----+--------------+-----------+--------------+------------+-------+------------+------+-----+| 100100 | 李明 | 男 | 副教授 | 硕士 | 党员 | 1967-02-01 | 否 | 1989-09-01 | B001 | 是 || 100101 | 李小光 | 男 | 讲师 | 本科 | 党员 | 1985-03-01 | 否 | 1990-10-02 | B001 | 是 || 100102 | 张伟键 | 男 | 教授 | 本科 | 党员 | 1965-05-06 | 是 | 1987-07-08 | B003 | 是 || 100103 | 石小华 | 女 | 教授 | 硕士 | 党员 | 1978-06-07 | 是 | 1992-01-01 | A001 | 是 || 100104 | 黄莉 | 女 | 助讲 | 硕士 | 群众 | 1986-03-04 | 否 | 2001-05-06 | A002 | 是 || 100105 | 余明平 | 男 | 教授 | 硕士 | 党员 | 1960-05-12 | 是 | 1983-04-05 | B001 | 是 || 100106 | 苏小明 | 男 | 教授 | 硕士 | 群众 | 1956-04-13 | 是 | 1983-04-03 | B003 | 是 || 100107 | 汤光明 | 男 | 教授 | 硕士 | 群众 | 1983-01-04 | 是 | 2007-12-06 | A004 | 是 || 100108 | 谢建设 | 男 | 副教授 | 博士 | 民进 | 1987-02-08 | 否 | 2006-08-15 | A005 | 是 || 100109 | 胡晓群 | 女 | 讲师 | 博士 | 党员 | 1990-09-28 | 否 | 2012-05-23 | B005 | 是 || 100330 | 李正中 | 男 | 副教授 | 硕士 | 群众 | 1978-10-29 | 否 | 1995-10-01 | B002 | 是 || 100331 | 王君君 | 女 | 教授 | 博士 | 党员 | 1956-11-18 | 否 | 1978-12-07 | B003 | 是 || 100332 | 赵剑 | 男 | 讲师 | 博士 | 党员 | 1967-12-25 | 否 | 1989-04-08 | B005 | 是 || 100333 | 欧阳 | 女 | 副教授 | 博士 | 民进 | 1966-03-08 | 否 | 1988-02-09 | B003 | 是 || 200100 | 李明义 | 男 | 讲师 | 硕士 | 党员 | 1965-04-17 | 否 | 1987-08-10 | B005 | 是 || 200101 | 孙美灵 | 男 | 讲师 | 硕士 | 党员 | 1977-05-16 | 否 | 1998-09-11 | B003 | 是 || 200102 | 王世明 | 男 | 副教授 | 硕士 | 党员 | 1976-03-21 | 否 | 1996-07-21 | A004 | 是 || 200103 | 张平娜 | 女 | 讲师 | 硕士 | 党员 | 1989-04-23 | 否 | 2008-06-22 | A001 | 是 || 200104 | 李美丽 | 女 | 讲师 | 博士 | 九三学社 | 1982-12-01 | 是 | 1992-05-01 | B001 | 是 || 200105 | 苏珍珍 | 女 | 副教授 | 本科 | 党员 | 1966-08-11 | 是 | 1985-08-01 | B003 | 是 || 200220 | 张白燕 | 女 | 讲师 | 博士 | 群众 | 1987-05-01 | 是 | 2011-09-02 | A001 | 是 || 200221 | 李青青 | 女 | 副教授 | 本科 | 群众 | 1964-10-06 | 是 | 1989-04-03 | A001 | 是 |+--------+-----------+-----+--------------+-----------+--------------+------------+-------+------------+------+-----+22 rows in set (0.01 sec)mysql&gt; select E_name, E_ID,sex from employees -&gt; where date(Gz_time) between '1990-10-02' and '2000-10-02' ;+-----------+--------+-----+| E_name | E_ID | sex |+-----------+--------+-----+| 李小光 | 100101 | 男 || 石小华 | 100103 | 女 || 李正中 | 100330 | 男 || 孙美灵 | 200101 | 男 || 王世明 | 200102 | 男 || 李美丽 | 200104 | 女 |+-----------+--------+-----+6 rows in set (0.00 sec)mysql&gt; 数值处理函数 函数 描述 Abs（ ） 返回一个数的绝对值 exp（） 返回一个数的值数值 mod（） 返回除操作的余数 rand（） 返回一个随机数 sin（） 返回一个角度的正弦 cos（） 返回一个角度的余弦 tan（） 返回一个角度的正切 sqrt（） 返回一个角度的平方根 pi（） 返回圆周率 汇总数据（聚集函数）聚集函数 聚集函数（aggregate function） 运行在行组上，计算和返回单个值的函数。 sql中使用的聚集函数 函数 描述 avg（） 返回某列的平均值 max（） 返回某列的最大值 min（） 返回某列的最小值 sum（） 返回某列的和 count（） 返回 某列的行数 AVG（）函数 求取某列的平均值 12345678910mysql&gt; select avg(number_1) as avg_number_1 -&gt; from jisuan ;+--------------+| avg_number_1 |+--------------+| 4.7500 |+--------------+1 row in set (0.01 sec)mysql&gt; MAX（）函数 返回某列的最大值 12345678910mysql&gt; select max(number_1) as max_number_1 -&gt; from jisuan ;+--------------+| max_number_1 |+--------------+| 8 |+--------------+1 row in set (0.00 sec)mysql&gt; count（）函数 COUNT()函数进行计数。可利用COUNT()确定表中行的数目或符合特 定条件的行的数目。 使用COUNT(*)对表中行的数目进行计数，不管表列中包含的是空 值（NULL）还是非空值。  使用 COUNT(column) 对特定列中具有值的行进行计数， 忽略NULL值。 1234567891011mysql&gt; select count(number_1) as -&gt; count_number_1 -&gt; from jisuan ;+----------------+| count_number_1 |+----------------+| 4 |+----------------+1 row in set (0.01 sec)mysql&gt; 聚集不同的值 之前在select部分使用distinct语句去除重复值检索 以上五个函数都称为聚集函数 以上5个聚集函数都可以如下使用： 对所有的行执行计算，指定ALL参数或不给参数（因为ALL是默认 行为）；  只包含不同的值，指定DISTINCT参数。 12345678910111213141516171819202122mysql&gt; select * from jisuan;+----------+----------+| number_1 | number_2 |+----------+----------+| 8 | 4 || 3 | 5 || 5 | 2 || 3 | 7 |+----------+----------+4 rows in set (0.00 sec)mysql&gt; select avg(distinct number_1) -&gt; as avg_number -&gt; from jisuan;+------------+| avg_number |+------------+| 5.3333 |+------------+1 row in set (0.01 sec)mysql&gt; 这样就可以排除重复值排除一些重复的值以来提高平均值的品质 组合聚集函数 目前为止的所有聚集函数例子都只涉及单个函数。但实际上SELECT 语句可根据需要包含多个聚集函数 123456789101112mysql&gt; select avg(number_1), -&gt; max(number_1), -&gt; min(number_1), -&gt; count(*) from jisuan ;+---------------+---------------+---------------+----------+| avg(number_1) | max(number_1) | min(number_1) | count(*) |+---------------+---------------+---------------+----------+| 4.7500 | 8 | 3 | 4 |+---------------+---------------+---------------+----------+1 row in set (0.01 sec)mysql&gt; 数据分组创建分组 分组是在SELECT语句的GROUP BY子句中建立的 GROUP BY 语法 1234SELECT column_name, function(column_name)FROM table_nameWHERE column_name operator valueGROUP BY column_name; 数据库employee_tbl 12345678910111213mysql&gt; select * from employee_tbl ;+----+--------+---------------------+--------+| id | name | date | singin |+----+--------+---------------------+--------+| 1 | 小明 | 2016-04-22 15:25:33 | 1 || 2 | 小王 | 2016-04-20 15:25:47 | 3 || 3 | 小丽 | 2016-04-19 15:26:02 | 2 || 4 | 小王 | 2016-04-07 15:26:14 | 4 || 5 | 小明 | 2016-04-11 15:26:40 | 4 || 6 | 小明 | 2016-04-04 15:26:54 | 2 |+----+--------+---------------------+--------+6 rows in set (0.01 sec) 检索出他们的登陆次数 12345678910111213mysql&gt; select name, count(*)使用 count 函数计数 -&gt; from employee_tbl -&gt; group by name ; 依据 name 列分组+--------+----------+| name | count(*) |+--------+----------+| 小明 | 3 || 小王 | 2 || 小丽 | 1 |+--------+----------+3 rows in set (0.00 sec)mysql&gt; 在具体使用GROUP BY子句前，需要知道一些重要的规定。 ​  GROUP BY子句可以包含任意数目的列。这使得能对分组进行嵌套， 为数据分组提供更 细 致的控制。  如果在GROUP BY子句中嵌套了分组，数据将在最后规定的分组上进行汇总。换句话 说， 在建立分组时，指定的所有列都一起计算 （所以不能从个别的列取回数据）。  GROUP BY 子句中列出的每个列都必须是检索列或有效的表达式 （但不能是聚数）。 如果在 SELECT 中使用表达式， 则必须在GROUP BY子句中指定相同的表达式。不能 使用 别名。 ​  除聚集计算语句外，SELECT语句中的每个列都必须在GROUP BY子句中给出。 ​  如果分组列中具有NULL值，则NULL将作为一个分组返回。如果列中有多行NULL值， 它 们将分为一组。 ​  GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前。 过滤分组 我们将使用 having 过滤分组 之前说的 where 只能过滤行 12345678910111213mysql&gt; select name ,count(*) -&gt; from employee_tbl -&gt; group by name -&gt; having count(*) &gt;= 2 ;//使用 having 过滤分组+--------+----------+| name | count(*) |+--------+----------+| 小明 | 3 || 小王 | 2 |+--------+----------+2 rows in set (0.00 sec)mysql&gt; 分组和排序之间的关系 order by group by 排序产生的输出 分组行 但输出可能不是分组的排序 任意列都可以使用（甚至非选择的列也可以使用） 只可能使用选择列或表达式列 而且必须使用每个选择列表达式 不一定需要 如果与聚集函数一起使用列（或表达式）则必须使用 select 语句顺序 子句 说明 是否必须使用 select 要返回的列或者表达式 是 from 从中检索数据的表 尽在从表中选择数据的时候使用 where 行级过滤 否 group by 分组说明 仅在按组计算聚集是使用 having 组级过滤 否 order by 输出排序顺序 否 limit 要检索的行数 否 使用子查询使用子查询进行过滤 SQL还允许创建子查询（subquery），即嵌套在其他查询中的查询。 为什么要这样做呢？理解这个概念的最好方法是考察几个例子 123456789mysql&gt; select * from departments where id = (select D_id from employees where E_name = '李明' ); //简单的字查询演示 这样就省去了连续查询两个表的繁琐过程+------+--------------+| id | name |+------+--------------+| B001 | 信息学院 |+------+--------------+1 row in set (0.00 sec)mysql&gt; 联结表关系表 关系表的设计就是要保证把信息分解成多个表，一类数据 一个表。各表通过某些常用的值（即关系设计中的（relational））互相关联 外键（foreign key） 外键为某个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系。 使用联结表的原因 如果数据存储在多个表中，怎样用单条SELECT语句检索出数据？ 答案是使用联结。简单地说，联结是一种机制，用来在一条SELECT 语句中关联表，因此称之为联结。使用特殊的语法，可以联结多个表返 回一组输出，联结在运行时关联表中正确的行。","link":"/2021/02/25/MYSQL_purekit/"}],"tags":[{"name":"教程","slug":"教程","link":"/tags/%E6%95%99%E7%A8%8B/"},{"name":"Github","slug":"Github","link":"/tags/Github/"},{"name":"PicGo","slug":"PicGo","link":"/tags/PicGo/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"SVG","slug":"SVG","link":"/tags/SVG/"},{"name":"XML","slug":"XML","link":"/tags/XML/"},{"name":"校园网","slug":"校园网","link":"/tags/%E6%A0%A1%E5%9B%AD%E7%BD%91/"},{"name":"VPN","slug":"VPN","link":"/tags/VPN/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"viewBinding","slug":"viewBinding","link":"/tags/viewBinding/"},{"name":"编程","slug":"编程","link":"/tags/%E7%BC%96%E7%A8%8B/"},{"name":"水博客","slug":"水博客","link":"/tags/%E6%B0%B4%E5%8D%9A%E5%AE%A2/"},{"name":"WLAN","slug":"WLAN","link":"/tags/WLAN/"},{"name":"PHP","slug":"PHP","link":"/tags/PHP/"},{"name":"Laravel","slug":"Laravel","link":"/tags/Laravel/"},{"name":"Cmposer","slug":"Cmposer","link":"/tags/Cmposer/"},{"name":"高数","slug":"高数","link":"/tags/%E9%AB%98%E6%95%B0/"},{"name":"Android Studio","slug":"Android-Studio","link":"/tags/Android-Studio/"},{"name":"笔记","slug":"笔记","link":"/tags/%E7%AC%94%E8%AE%B0/"},{"name":"MYSQL","slug":"MYSQL","link":"/tags/MYSQL/"}],"categories":[{"name":"PicGo","slug":"PicGo","link":"/categories/PicGo/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"工具","slug":"工具","link":"/categories/%E5%B7%A5%E5%85%B7/"},{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"Laravel","slug":"Laravel","link":"/categories/Laravel/"},{"name":"高数","slug":"高数","link":"/categories/%E9%AB%98%E6%95%B0/"},{"name":"MYSQL","slug":"MYSQL","link":"/categories/MYSQL/"}]}